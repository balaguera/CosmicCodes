/** @file PowerSpectrumF.cpp
 *
 * @brief This file contains a public PowerSpectrum-class member function
 * @details Generates thee estimates of power spectrum
 * @author Andres Balaguera Antolinez
 * @date 2008-2023
 */

#include "../Headers/PowerSpectrumF.h"

// *************************************************************************************
// *************************************************************************************
// *************************************************************************************
/*
  #ifdef _USE_ALL_PK_
  void PowerSpectrumF::add_catalogues()
  {
  this->tracer_cat.set_params_catalog(this->params);
  this->tracer_cat.type_of_object="TRACfER";
  this->tracer_cat.read_catalog(this->file_data,0);
  this->gc_n_columns=this->tracer_cat.NCOLS;
  this->N_galaxy=this->tracer_cat._NOBJS();

  if(true==this->params._use_random_catalog())
  {
  this->tracer_cat.set_params_catalog(this->params);
  this->tracer_cat.type_of_object="RANDOM";
  this->random_cat.read_catalog(this->file_random,0);
  this->rc_n_columns=this->random_cat.NCOLS;
  this->N_random=this->random_cat._NOBJS();
  }
  }
  #endif
*/
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
void PowerSpectrumF::set_output_filenames ()
{

#ifdef _USE_REDSHIFT_BINS_
  string aux_name=this->params._Name_survey()+"_zmin_"+to_string(this->params._redshift_min_sample()) +"_zmax_"+to_string(this->params._redshift_max_sample());
  this->params.set_Name_survey(aux_name);
#endif
#ifdef _REDSHIFT_SPACE_
  this->file_MCF = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_mark"+this->params._mark()+"_Real"+to_string(this->params._realization())+"_RSS.txt";
  this->file_power  = this->params._Output_directory()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+"_RSS.txt";
  this->file_power_marked  = this->params._Output_directory()+this->params._statistics()+"_marked_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+"_RSS.txt";
  this->file_power_log      = this->params._Output_directory()+this->params._statistics()+"_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power_log()+"_RSS.log";
#else
  this->file_power  = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+this->params._file_power()+".txt";
  this->file_power_marked  = this->params._Output_directory()+this->params._statistics()+"_marked_"+params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+".txt";
  this->file_power_log      = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power_log()+".log";
  this->file_MCF = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_mark"+this->params._mark()+"_Real"+to_string(this->params._realization())+".txt";
#endif
  this->file_power  = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+this->params._file_power()+".txt";
  this->file_power_real_space  = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+".txt";
  this->file_power_redshift_space  = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+"_RSS.txt";
  this->file_power_marked_real_space  = this->params._Output_directory()+this->params._statistics()+"_marked_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+".txt";
  this->file_power_marked_redshift_space  = this->params._Output_directory()+this->params._statistics()+"_marked_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+"_RSS.txt";
  this->file_power_cross  = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power()+".txt_CROSS";
  this->file_dndz           = this->params._Output_directory()+"dndz_"+params._Name_survey()+this->params._file_dndz()+".txt";
  this->file_power2d        = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power2d()+".txt";
  this->file_power2d_mk     = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_power2d_mk()+".txt";
  this->file_window         = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_window();
  this->file_bispectrum     = this->params._Output_directory()+this->params._statistics()+"_"+this->params._Name_survey()+"_Nft"+to_string(this->params._Nft())+"_"+this->params._mass_assignment_scheme()+"_"+params._file_bispectrum()+".txt";
  //file_power_fb       = file_power_cl; // ???
  this->file_data = this->params._file_catalogue();
  this->file_random = this->params._file_random();
}

// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

#if defined (_USE_MASS_CUTS_PK_) || defined (_USE_ALL_PK_)
void PowerSpectrumF::add_catalogues(real_prec mcut)
{
#elif defined (_USE_MASS_BINS_PK_)
  void PowerSpectrumF::add_catalogues(real_prec m_min, real_prec m_max)
  {
#endif

    this->So.enter(__PRETTY_FUNCTION__);

    this->tracer_cat.set_params(this->params);
    this->tracer_cat.set_type_of_object(this->params._type_of_object());

#if defined(_USE_MASS_CUTS_PK_) || defined (_USE_ALL_PK_)
    this->tracer_cat.read_catalog(this->params._Input_dir_cat()+ this->file_data, mcut);
#elif defined (_USE_MASS_BINS_PK_)
    this->tracer_cat.read_catalog(this->params._Input_dir_cat()+file_data,m_min,m_max);
#endif
    this->gc_n_columns=this->tracer_cat.NCOLS;
    this->N_galaxy=this->tracer_cat._NOBJS();



    if(true==this->params._use_random_catalog())
      {
        this->random_cat.set_params(this->params);// this must come first than set_type_of_object
        this->random_cat.set_type_of_object("RANDOM");
#if defined(_USE_MASS_CUTS_PK_) || defined (_USE_ALL_PK_)
    this->random_cat.read_catalog(this->params._Input_dir_cat()+this->file_random, mcut);
#elif defined (_USE_MASS_BINS_PK_)
    this->random_cat.read_catalog(this->params._Input_dir_cat()+file_random,m_min,m_max);
#endif
    this->rc_n_columns=this->random_cat.NCOLS;
    this->N_random=this->random_cat._NOBJS();
      }
  }

  // This method is only used for the window function.
  void PowerSpectrumF::add_random_catalogue()
  {
    this->So.enter(__PRETTY_FUNCTION__);
    this->random_cat.set_params(this->params);// this must come first than set_type_of_object
    this->random_cat.set_type_of_object("RANDOM");

#if defined(_USE_MASS_CUTS_PK_) || defined (_USE_ALL_PK_)
    this->random_cat.read_catalog(this->params._Input_dir_cat()+this->file_random, 0.);
#elif defined (_USE_MASS_BINS_PK_)
    this->random_cat.read_catalog(this->params._Input_dir_cat()+file_random,0,LARGE_NUMBER);
#endif
    this->rc_n_columns=this->random_cat.NCOLS;
    this->N_random=this->random_cat._NOBJS();
  }

  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************


  void PowerSpectrumF::write_power_spectrum() ///PLeas unify the name of this function with write_power and modes
  {
    // Write P(k) to file:

#ifdef _VERBOSE_POWER_
    this->So.enter(__PRETTY_FUNCTION__);
#endif

    if(this->params._statistics()=="Pk_fkp")
      {
#ifdef _WRITE_MULTIPOLES_
    File.write_to_file(this->file_power,this->kvector_data,this->pk0,this->pk2,this->pk4,this->sigma_fkp,this->modes_g);
#else
    File.write_to_file(this->file_power,this->kvector_data,this->pk0,this->modes_g);
#endif
    // Write P(kperp, kpar) to file:
#ifdef _WRITE_2DPOWER_
    File.write_to_file(this->file_power2d,this->kvector_data2d,this->kvector_data2d,this->pkk);
    //Write P(k, mu) to file:
    File.write_to_file(file_power2d_mk,this->muvector,this->kvector_data2d,this->pmk);
#endif
    // Write W(k):
    if(true==this->params._use_random_catalog())
      File.write_to_file(this->file_window,this->kvector_window,this->pk_w);
      }
    else if(this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb"  || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ysc" || this->params._statistics()=="Pk_y_ds")
      {
    File.write_to_file(file_power,this->kvector_data,this->pk0,this->pk2,this->pk4,this->sigma_fkp,this->modes_g);
      }
    else if(this->params._statistics()=="Bk_fkp")
      File.write_to_file(file_bispectrum,kvector_data_b,bispectrum,sn_bispectrum, modes_tri);
  }

  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************

  void PowerSpectrumF::write_power_spectrum(bool write_sigma) ///PLeas unify the name of this function with write_power and modes
  {
#ifdef _VERBOSE_POWER_
    this->So.enter(__PRETTY_FUNCTION__);
#endif
    if(this->params._statistics()=="Pk_fkp")
      {
#ifdef _WRITE_MULTIPOLES_
        if(true==write_sigma)
      File.write_to_file(this->file_power,this->kvector_data,this->pk0,this->pk2,this->pk4,this->sigma_fkp,this->modes_g);
        else
      File.write_to_file(this->file_power,this->kvector_data,this->pk0,this->pk2,this->pk4,this->modes_g);
#else
        File.write_to_file2(this->file_power,this->kvector_data,this->pk0,this->modes_g,write_sigma);
#endif
    // Write P(kperp, kpar) to file:
#ifdef _WRITE_2DPOWER_
    File.write_to_file(this->file_power2d,this->kvector_data2d,this->kvector_data2d,this->pkk);
    //Write P(k, mu) to file:
    File.write_to_file(file_power2d_mk,this->muvector,this->kvector_data2d,this->pmk);
#endif
    // Write W(k):
    if(true==this->params._use_random_catalog())
      File.write_to_file(this->file_window,this->kvector_window,this->pk_w);
      }
    else if(this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb"  || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ysc" || this->params._statistics()=="Pk_y_ds")
      {
    File.write_to_file(file_power,this->kvector_data,this->pk0,this->pk2,this->pk4,this->sigma_fkp,this->modes_g);
      }
    else if(this->params._statistics()=="Bk_fkp")
      File.write_to_file(file_bispectrum,kvector_data_b,bispectrum,sn_bispectrum, modes_tri);
  }
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************


  void PowerSpectrumF::write_power_and_modes()
  {
#ifdef _VERBOSE_POWER_
    this->So.enter(__PRETTY_FUNCTION__);
#endif
    File.write_to_file2(this->file_power,this->kvector_data,this->pk0,this->modes_g,true);
    if(this->params._use_random_catalog())
      File.write_to_file2(this->file_window,this->kvector_data,this->pk_w,this->modes_g,true);
  }

  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  void PowerSpectrumF::write_power_and_modes(string file)
  {
#ifdef _VERBOSE_POWER_
    this->So.enter(__PRETTY_FUNCTION__);
#endif
    File.write_to_file2(file,this->kvector_data,this->pk0,this->modes_g, true);
  }
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************

  void PowerSpectrumF::write_power_spectrum_grid(string output_file)
  {
#ifdef _VERBOSE_POWER_
    this->So.enter(__PRETTY_FUNCTION__);
    So.message_screen("Writing outputs");
#endif
    File.write_to_file(output_file,this->kvector_data,this->pk0,this->pk2,this->pk4,this->sigma_fkp,this->modes_g);
  }
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************

  void PowerSpectrumF::compute_marked_correlation_function()
  {
    this->So.enter(__PRETTY_FUNCTION__);
    this->params.set_statistics("MCF");

#if defined (_USE_MASS_CUTS_PK_) || defined (_USE_ALL_PK_)
    this->add_catalogues(0);
#else
    this->add_catalogues(0,1e20);
#endif

    vector<ULONG>count(this->params._Nbins_cf(),0);
    vector<real_prec>mcount(this->params._Nbins_cf(),0);
    vector<real_prec>vcount(this->params._Nbins_cf(),0);
    vector<real_prec>mvcount(this->params._Nbins_cf(),0);
    vector<real_prec> rbin(this->params._Nbins_cf(),0);

    real_prec Deltar=this->params._rbin_type() == "linear"? (this->params._rmax_cf()-this->params._rmin_cf())/(static_cast<real_prec>(this->params._Nbins_cf())) :  (log10(this->params._rmax_cf()/this->params._rmin_cf()))/static_cast<real_prec>(this->params._Nbins_cf());

    int NTHREADS = 1;
#ifdef _USE_OMP_
    NTHREADS=_NTHREADS_;
#endif

    So.message_screen("Measuring Marked Correlation function using",NTHREADS," threads");
    if(this->params._rbin_type() =="linear")
      for (int i=0;i<rbin.size();++i)
        rbin[i]=this->params._rmin_cf()+(i+0.5)*Deltar;
    else
      for (int i=0;i<rbin.size();++i)
    rbin[i]=pow(10, log10(this->params._rmin_cf())+(i+0.5)*Deltar);

    real_prec mean_mass=0;
    if(this->params._i_mass_g()>0){
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:mean_mass)
#endif
      for (ULONG i=0;i<this->N_galaxy; ++i)
    mean_mass+=this->tracer_cat.Halo[i].mass;

      mean_mass=(static_cast<double>(mean_mass))/(static_cast<double>(this->N_galaxy));
#ifdef _FULL_VERBOSE_
      So.message_screen("Mean mass = ", mean_mass);
#endif
    }

    real_prec mean_vmax=0;
    if(this->params._i_vmax_g()>0){
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:mean_vmax)
#endif
      for (ULONG i=0;i<this->N_galaxy; ++i)
    mean_vmax+=this->tracer_cat.Halo[i].vmax;
      mean_vmax=(static_cast<double>(mean_vmax))/(static_cast<double>(this->N_galaxy));
#ifdef _FULL_VERBOSE_
      So.message_screen("Mean vmax = ", mean_vmax);
#endif
    }


#ifdef _REDSHIFT_SPACE_
    real_prec rsd_x=1.0;
    real_prec rsd_y=1.0;
    real_prec rsd_z=1.0;

    if(false==this->params._redshift_space_coords_g())
      switch(LOS)
    {
    case(1):rsd_x*=1.0;rsd_y*=0.0;rsd_z*=0.0; break;
    case(2):rsd_x*=0.0;rsd_y*=1.0;rsd_z*=0.0; break;
    case(3):rsd_x*=0.0;rsd_y*=0.0;rsd_z*=1.0; break;
    }
    else // of coordinates have already the rsd included (as in a real catalog) and we still use _REDSHIFT_SPACE_ we have to set all rsd to 0
      {
    rsd_x=0.0;
    rsd_y=0.0;
    rsd_z=0.0;
      }

    // Conversion from km/s to Mpc/h for RSD
    real_prec conversion_factor=1.;
    if(this->params._redshift_space_coords_g() == false)
      {
    if("kmps"==this->params._vel_units_g())
      conversion_factor=(1.+this->params.s_cosmo_pars.cosmological_redshift)/(this->c_Cf.Hubble_function(this->params.s_cosmo_pars.cosmological_redshift, (void *)&this->params.s_cosmo_pars));
    else if("alpt"==this->params._vel_units_g())
      conversion_factor= cgs_Mpc/(this->c_Cf.Hubble_function(this->params.s_cosmo_pars.cosmological_redshift, (void *)&this->params.s_cosmo_pars));
    else if("Mpcph"==this->params._vel_units_g())
      conversion_factor=1;
#ifdef _FULL_VERBOSE_
    So.message_screen("Current redshift =",this->params.s_cosmo_pars.cosmological_redshift);
    So.message_screen("Hubble function at current redshift =",this->c_Cf.Hubble_function(this->params.s_cosmo_pars.cosmological_redshift, (void *)&this->params.s_cosmo_pars));
    So.message_screen("Conversion factor =",conversion_factor);
#endif

    So.message_screen("Hubble function at current redshift =",this->c_Cf.Hubble_function(this->params.s_cosmo_pars.cosmological_redshift, (void *)&this->params.s_cosmo_pars));

      }
#endif
    real_prec lrmin= this->params._rbin_type() == "linear" ? this->params._rmin_cf():  log10(this->params._rmin_cf());
    vector<ULONG> count_priv(this->params._Nbins_cf()*NTHREADS,0);
    vector<real_prec> mcount_priv(this->params._Nbins_cf()*NTHREADS,0);
    vector<real_prec> vcount_priv(this->params._Nbins_cf()*NTHREADS,0);
    vector<real_prec> mvcount_priv(this->params._Nbins_cf()*NTHREADS,0);
#pragma omp parallel num_threads(NTHREADS)
    {
      const int ithread = omp_get_thread_num();
      for(ULONG i=0;i<this->params._Nbins_cf();++i)count_priv[this->params._Nbins_cf()*ithread+i]=0;
      for(ULONG i=0;i<this->params._Nbins_cf();++i)count_priv[this->params._Nbins_cf()*ithread+i]=0;
#pragma omp for
      for (ULONG i=0;i<this->N_galaxy;++i)
    {
#ifdef _REDSHIFT_SPACE_
      real_prec vx=this->tracer_cat.Halo[i].vel1;
      real_prec vy=this->tracer_cat.Halo[i].vel2;
      real_prec vz=this->tracer_cat.Halo[i].vel3;
      real_prec x=this->tracer_cat.Halo[i].coord1+rsd_x*conversion_factor*vx;
      real_prec y=this->tracer_cat.Halo[i].coord2+rsd_y*conversion_factor*vy;
      real_prec z=this->tracer_cat.Halo[i].coord3+rsd_z*conversion_factor*vz;
#else
      real_prec x=this->tracer_cat.Halo[i].coord1;
      real_prec y=this->tracer_cat.Halo[i].coord2;
      real_prec z=this->tracer_cat.Halo[i].coord3;
#endif
      real_prec mass=this->tracer_cat.Halo[i].mass;
      real_prec sigma=this->tracer_cat.Halo[i].vmax;
      for (ULONG j=i+1;j<this->N_galaxy;++j)
        {
#ifdef _REDSHIFT_SPACE_
          real_prec vxp=this->tracer_cat.Halo[j].vel1;
          real_prec vyp=this->tracer_cat.Halo[j].vel2;
          real_prec vzp=this->tracer_cat.Halo[j].vel3;
          real_prec dx=x-(this->tracer_cat.Halo[j].coord1+rsd_x*conversion_factor*vxp);
          real_prec dy=y-(this->tracer_cat.Halo[j].coord2+rsd_y*conversion_factor*vyp);
          real_prec dz=z-(this->tracer_cat.Halo[j].coord3+rsd_z*conversion_factor*vzp);
#else
          real_prec dx=x-this->tracer_cat.Halo[j].coord1;
          real_prec dy=y-this->tracer_cat.Halo[j].coord2;
          real_prec dz=z-this->tracer_cat.Halo[j].coord3;
#endif
          real_prec pmass=this->tracer_cat.Halo[j].mass;
          real_prec psigma=this->tracer_cat.Halo[j].vmax;
          real_prec idr=dx*dx+dy*dy+dz*dz;
          real_prec rd=  this->params._rbin_type() == "linear" ? sqrt(idr): 0.5*log10(idr);
          ULONG ind = get_bin(rd,lrmin,this->params._Nbins_cf(),Deltar,false);
          if(ind < this->params._Nbins_cf())
        {
          count_priv[ind+this->params._Nbins_cf()*ithread]++;
          mcount_priv[ind+this->params._Nbins_cf()*ithread]+=0.5*(mass+pmass);
          vcount_priv[ind+this->params._Nbins_cf()*ithread]+=0.5*(sigma+psigma);
          mvcount_priv[ind+this->params._Nbins_cf()*ithread]+=0.25*((mass+pmass)*(psigma+sigma));
        }
    }
}

#pragma omp for
      for(ULONG i=0;i<this->params._Nbins_cf();++i)
    for(ULONG t=0;t<NTHREADS;++t){
      mcount[i]+= mcount_priv[i+this->params._Nbins_cf()*t];
      vcount[i]+= vcount_priv[i+this->params._Nbins_cf()*t];
      mvcount[i]+= mvcount_priv[i+this->params._Nbins_cf()*t];
    }

#pragma omp for
      for(ULONG i=0;i<this->params._Nbins_cf() ;++i)
    for(ULONG t=0;t<NTHREADS;++t)
      count[i]+= count_priv[i+this->params._Nbins_cf()*t];
    }

    this->tracer_cat.Halo.clear();
    this->tracer_cat.Halo.shrink_to_fit();

    So.DONE();
    cout<<CYAN<<" Done"<<RESET<<endl;
    for(int i=0;i<mcount.size();++i)
      mcount[i]/=(pow(mean_mass,1)*static_cast<real_prec>(count[i]));
    for(int i=0;i<mcount.size();++i)
      vcount[i]/=(pow(mean_vmax,1)*static_cast<real_prec>(count[i]));
    for(int i=0;i<mcount.size();++i)
      mvcount[i]/=(mean_vmax*mean_mass*static_cast<real_prec>(count[i]));
    ofstream mcor; mcor.open(this->file_MCF.c_str());
    mcor.precision(8);
    for(int i=0;i<mcount.size();++i)mcor<<rbin[i]<<"\t"<<mcount[i]<<"\t"<<vcount[i]<<"\t"<<mvcount[i]<<"\t"<<count[i]<<endl;
    mcor.close();
    cout<<CYAN<<"Output in file "<<GREEN<<this->file_MCF.c_str()<<RESET<<endl;
    cout<<CYAN<<"Done"<<endl;
  }

  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  void PowerSpectrumF::compute_cross_power_spectrum_grid(bool dm, vector<real_prec>&X,vector<real_prec>&Y, bool  get_cross_coeff)
  {
#ifdef _VERBOSE_POWER_
    this->So.enter(__PRETTY_FUNCTION__);
#endif
    real_prec ngal_new=0;

    //-------------------------------------------------
    this->fftw_functions.data_g.clear();
    this->fftw_functions.data_g.shrink_to_fit();
    this->fftw_functions.data_g.resize(this->params._NGRID(),0);

    if (this->params._input_type_two()=="delta_grid")
      {
#pragma omp parallel for
        for(ULONG i=0;i<this->params._NGRID();++i)
          this->fftw_functions.set_data_g(i,static_cast<real_prec>(Y[i]));
        ngal_new=this->params._ngal_delta();
      }
    else if (this->params._input_type_two()=="density_grid")
      {
#pragma omp parallel for reduction(+:ngal_new)
    for(ULONG i=0;i<this->params._NGRID();++i)
      ngal_new+=static_cast<real_prec>(Y[i]);
    real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());
    So.message_screen("Y-type density_grid with mean",nmean);
#pragma omp parallel for
        for(ULONG i=0;i<this->params._NGRID();++i)
          this->fftw_functions.set_data_g(i,(static_cast<real_prec>(Y[i])/static_cast<real_prec>(nmean))-1.);
    this->params.set_ngal_delta(ngal_new);
      }

    this->fftw_functions.set_shot_noise(0);
    real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
    this->fftw_functions.set_normal_power(pow(factor,-2));

    //-------------------------------------------------
    //-------------------------------------------------
    this->fftw_functions.data_gp.clear();
    this->fftw_functions.data_gp.shrink_to_fit();
    this->fftw_functions.data_gp.resize(this->params._NGRID(),0);

    ngal_new=0;
    if (this->params._input_type()=="delta_grid")
      {
#ifdef _USE_OMP_
#pragma omp parallel
#endif
    for(ULONG i=0;i<this->params._NGRID();++i)
          this->fftw_functions.set_data_gp(i,static_cast<real_prec>(X[i]));
    So.message_screen("X-type delta_grid");
      }
    else if (this->params._input_type()=="density_grid")
      {
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new)
#endif
    for(ULONG i=0;i<this->params._NGRID();++i)
      ngal_new+=static_cast<real_prec>(X[i]);
    real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());
    So.message_screen("X-type density_grid with mean", nmean);

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
    for(ULONG i=0;i<this->params._NGRID();++i)
          this->fftw_functions.set_data_gp(i,(static_cast<real_prec>(X[i])/static_cast<real_prec>(nmean))-1.);
      }

    this->fftw_functions.set_shot_noise2(0);
    factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
    this->fftw_functions.set_normal_power_two(pow(factor,-2));
    this->fftw_functions.resize_fftw_vectors();
    this->kvector_data.clear();
    this->kvector_data.shrink_to_fit();
    for(ULONG i=0;i<this->params._d_Nnp_data();i++)
      this->kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));

    this->pk0.clear();
    this->pk0.shrink_to_fit();
    this->pk0.resize(this->params._d_Nnp_data(),0);
    this->modes_g.clear();
    this->modes_g.resize(this->params._d_Nnp_data(),0);
    //#if !defined (_USE_BIAS_OBJECT_TO_OBJECT_) || !defined (_USE_CROSS_CORRELATION_CONF_SPACE_)
#if !defined (_USE_CROSS_CORRELATION_CONF_SPACE_)
    fftw_functions.cross_power_spectrum_fkp(this->pk0,this->modes_g,  get_cross_coeff);
#else
    vector<real_prec>corr(this->params._NGRID(),0);
    fftw_functions.cross_power_spectrum_fkp(this->pk0,this->modes_g,corr);
#endif

    this->write_power_and_modes(this->file_power_cross);
    fftw_functions.data_g.clear();
    fftw_functions.data_g.shrink_to_fit();
    fftw_functions.data_gp.clear();
    fftw_functions.data_gp.shrink_to_fit();
  }

  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************
  // ****************************************************************************************************************************************************************************************************************

  void PowerSpectrumF::compute_cross_power_spectrum_grid(bool dm,string file_X, string file_Y, bool get_cross_coeff)
  {
#ifdef _VERBOSE_POWER_
    this->So.enter(__PRETTY_FUNCTION__);
#endif
    int NTHREADS=_NTHREADS_;
    omp_set_num_threads(NTHREADS);
    FileOutput File;

    real_prec ngal_new=0;

    fftw_functions.data_g.clear();
    fftw_functions.data_g.shrink_to_fit();
    fftw_functions.data_g.resize(this->params._NGRID(),0);


    vector<real_prec>Y(this->params._NGRID(),0);
    File.read_array_t<PrecType_Y>(file_Y, Y);

    if (this->params._input_type_two()=="delta_grid")
      {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
        for(ULONG i=0;i<this->params._NGRID();++i)
          fftw_functions.data_g[i]=static_cast<real_prec>(Y[i]);
        ngal_new=this->params._ngal_delta();
        So.message_screen("Y-type delta_grid");
      }
    else if (this->params._input_type_two()=="density_grid")
      {
#pragma omp parallel for reduction(+:ngal_new)
    for(ULONG i=0;i<this->params._NGRID();++i)
          ngal_new+=static_cast<real_prec>(Y[i]);
    real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());
        So.message_screen("Mean = ", nmean);
        So.message_screen("Y-type density_grid");

#pragma omp parallel for
    for(ULONG i=0;i<this->params._NGRID();++i)
          fftw_functions.data_g[i]=(static_cast<real_prec>(Y[i])/static_cast<real_prec>(nmean))-1.;
    this->params.set_ngal_delta(ngal_new);
      }


    if(true==this->params._SN_correction())
      fftw_functions.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);

    real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
    fftw_functions.set_normal_power(pow(factor,-2));

    Y.clear(); Y.shrink_to_fit();


    fftw_functions.data_gp.clear();
    fftw_functions.data_gp.shrink_to_fit();
    fftw_functions.data_gp.resize(this->params._NGRID(),0);
    ngal_new=0;

    vector<float>X(this->params._NGRID(),0);
    File.read_array_t<float>(file_X, X);


    if (this->params._input_type()=="delta_grid")
      {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
    for(ULONG i=0;i<this->params._NGRID();++i)
          fftw_functions.data_gp[i]=static_cast<real_prec>(X[i]);
    ngal_new=this->params._ngal_delta();
    So.message_screen("X-type delta_grid");
      }
    else if (this->params._input_type()=="density_grid")
      {

#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new)
#endif
    for(ULONG i=0;i<this->params._NGRID();++i)
          ngal_new+=static_cast<real_prec>(X[i]);
    real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());
        So.message_screen("Mean = ", nmean);
        So.message_screen("X-type = density_grid");

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
    for(ULONG i=0;i<this->params._NGRID();++i)
          fftw_functions.data_gp[i]=(static_cast<real_prec>(X[i])/static_cast<real_prec>(nmean))-1.;
      }


    fftw_functions.shot_noise2=0;
    factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
    fftw_functions.set_normal_power_two(pow(factor,-2));

    X.clear(); X.shrink_to_fit();



    if(false==dm && true==this->params._SN_correction())
      fftw_functions.shot_noise2=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);


    fftw_functions.write_fftw_parameters();
    fftw_functions.resize_fftw_vectors();

    kvector_data.clear();
    kvector_data.shrink_to_fit();
    for(int i=0;i<this->params._d_Nnp_data();i++)
      kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));

    this->pk0.clear();
    this->pk0.shrink_to_fit();
    this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
    this->modes_g.clear();
    this->modes_g.resize(this->params._d_Nnp_data(),0); //Monopole
//#if !defined _USE_BIAS_OBJECT_TO_OBJECT_ || !defined (_USE_CROSS_CORRELATION_CONF_SPACE_)
#if !defined (_USE_CROSS_CORRELATION_CONF_SPACE_)
    fftw_functions.cross_power_spectrum_fkp(this->pk0,this->modes_g, get_cross_coeff);
#else
    vector<real_prec>corr(this->params._NGRID(),0);
    fftw_functions.cross_power_spectrum_fkp(this->pk0,this->modes_g,corr);
#endif
    this->write_power_and_modes();


    fftw_functions.data_g.clear();
    fftw_functions.data_g.shrink_to_fit();
    fftw_functions.data_g.resize(this->params._NGRID(),0);
    fftw_functions.data_gp.clear();
    fftw_functions.data_gp.shrink_to_fit();
    fftw_functions.data_gp.resize(this->params._NGRID(),0);


  }
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // ********************************************************************************************************************************************************
  // This function is to be read from the cosmicatlas.cpp main function: verbose is to show detailed information, mcut is to force the analysis to have a minium cut in a given property
  // depending on w

  void PowerSpectrumF::compute_power_spectrum(bool verbose, bool mcut){

    time_t start;
    time (&start);

#ifdef _USE_OMP_
    int NTHREADS=_NTHREADS_;
    omp_set_num_threads(NTHREADS);
#endif

    if(true==this->params._weight_with_mass())
      {
        So.message_screen("***************************************************");
        So.message_screen("****Measuring the Mass weighted power spectrum****");
        So.message_screen("***************************************************");
      }

    string file_pow=this->file_power;
    int N_intervals=1;

#ifdef _USE_MASS_AS_OBSERVABLE_POWER_
#ifdef _USE_MASS_CUTS_PK_
    N_intervals=this->params._NMASScuts_power();
    mcut=true;
#elif defined _USE_MASS_BINS_PK_
    N_intervals=this->params._NMASSbins_power();
#endif
#elif defined _USE_VMAX_AS_PRIMARY_OBSERVABLE_POWER_
#ifdef _USE_MASS_CUTS_PK_  // here mass is meant for vmax, cuation
    So.message_warning("VMAX-cuts are NOT YET defined in param file", __PRETTY_FUNCTION__);
    exit(1);
#elif defined _USE_MASS_BINS_PK_
    N_intervals=this->params._NVMAXbins_power();
#endif
#endif

    int im=0;
#ifdef _USE_MASS_CUTS_PK_
    if(true==mcut)
    else
      {
    real_prec mcut_aux=MINIMUM_PROP_CUT;
#ifdef _USE_MASS_AS_OBSERVABLE_POWER_
    So.message_screen("Power spectrum mesasured with one mass-cut at" , mcut_aux, "Ms/h");
#elif defined _USE_VMAX_AS_PRIMARY_OBSERVABLE_POWER_
    So.message_screen("Power spectrum mesasured with one VMAX cut at" , mcut_aux, "km/s");
#endif
    if(true==this->params._weight_with_mass())
      So.message_screen("Mass weighted power spectrum");
#ifdef _USE_MASS_CUTS_PK_
      }
#endif

    for(im=0; im< N_intervals;++im)
      {
#elif defined (_USE_MASS_BINS_PK_)
        So.message_warning("Property-bins are defined in PowerSpectrumF::compute_power_spectrum");

#if defined _USE_RS_AS_OBSERVABLE_POWER_
    real_prec l_minp=log10(this->params._RSmin());
    real_prec l_maxp=log10(this->params._RSmax());
#elif defined _USE_SPIN_AS_OBSERVABLE_POWER_
    real_prec l_minp=log10(this->params._SPINmin());
    real_prec l_maxp=log10(this->params._SPINmax());
#endif


#ifdef _USE_VMAX_AS_PRIMARY_OBSERVABLE_POWER_
        for(int i=0;i<N_intervals;++i)cout<<"Bin "<<i<<"  :"<<this->params._VMAXbins_min(i)<<"  "<<this->params._VMAXbins_max(i)<<endl;
#else

        for(int i=0;i<N_intervals;++i)cout<<"Bin "<<i<<"  :"<<pow(10,this->params._MASSbins_min(i))<<"  "<<pow(10,this->params._MASSbins_max(i))<<endl;
#endif

#ifdef _JPAS_   // this moves the position of the men number denisty in the random prepared for jpas staged
        int i_Nw_ori_r=this->params._i_mean_density_r();
        int i_Nw_ori_g=this->params._i_mean_density_g();
#endif

        for(im=0; im<N_intervals;++im)
      {
#endif
#ifdef _JPAS_   // this moves the position of the men number denisty in the random prepared for jpas staged
            int new_col_nbar_r=i_Nw_ori_r+im;
            this->params.set_i_mean_density_r(new_col_nbar_r);
            int new_col_nbar_g=i_Nw_ori_g+im;
            this->params.set_i_mean_density_g(new_col_nbar_g);
#endif

            fftw_functions.set_imcut(im);

#ifdef _USE_MASS_CUTS_PK_
#ifdef _USE_MASS_AS_OBSERVABLE_POWER_
        this->file_power=file_pow+"_masscut"+to_string(im);
#elif defined (_USE_VMAX_AS_PRIMARY_OBSERVABLE_POWER_)
        this->file_power=file_pow+"_vmaxcut"+to_string(im);
#endif
#elif defined (_USE_MASS_BINS_PK_)

#ifdef _USE_MASS_AS_OBSERVABLE_POWER_
        this->file_power=file_pow+"_massbin"+to_string(im);
#elif defined (_USE_VMAX_AS_PRIMARY_OBSERVABLE_POWER_)
        this->file_power=file_pow+"_vmaxbin"+to_string(im);
#elif defined (_USE_RS_AS_OBSERVABLE_POWER_)
        this->file_power=file_pow+"_rsbin"+to_string(im);
#elif defined (_USE_SPIN_AS_OBSERVABLE_POWER_)
        this->file_power=file_pow+"_spinbin"+to_string(im);
#endif
#endif
        if(true==verbose)
          {
        if(this->params._statistics()=="Pk_fkp")So.welcome_message();
        if(this->params._statistics()=="Bk_fkp")So.welcome_message_bispectrum();
        if(this->params._statistics()=="Bk_fkp_fast")So.welcome_message_bispectrum_fast();
        if(this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb" || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ysc" || this->params._statistics()=="Pk_y_ds")So.welcome_message_yama();
          }

        if(2==this->params._sys_of_coord_g())
          So.write_cosmo_parameters((void *)&this->params.s_cosmo_pars);
        // ***********************************************************
        // Define some structures here
        s_parameters_box s_p_box;
        s_data_structure s_data_struct_r; // this is defiend here for the fkp error bars need the info from the randoms. So far at this point it is only defiend but not filled
        // ***********************************************************
        // Add random and galaxy catalogues
        this->File.input_type=this->params._input_type();

#if defined (_USE_MASS_CUTS_PK_) ||  defined (_USE_ALL_PK_)
        if(this->params._input_type()!="catalog")
          So.message_warning("Warning: expecting catalog to perform mass cuts when density field is provided");

        real_prec mm=0;
        if("catalog"==this->params._input_type())
#ifdef _USE_ALL_PK_
          if(this->params._i_mass_g()>0)
        mm=pow(10,this->params._LOGMASSmin());
          else
        mm=0;
#else
            mm=log10(this->params._MASScuts(i));
#endif
        if(this->params._input_type()=="catalog")
              this->add_catalogues(mm);

#elif defined (_USE_MASS_BINS_PK_)
#ifdef _USE_VMAX_AS_PRIMARY_OBSERVABLE_POWER_
            this->add_catalogues(this->params._VMAXbins_min(im),this->params._VMAXbins_max(im));
#elif defined _USE_MASS_AS_OBSERVABLE_POWER_
            this->add_catalogues(pow(10,this->params._MASSbins_min(im)),pow(10,this->params._MASSbins_max(im)));
#endif
#endif
        if(this->params._input_type()=="catalog")
          {
        // Tabulate r-z relation if radial coordinate is redshift
        vector<gsl_real>vzz(params._N_z_bins(),0);
        vector<gsl_real>vrc(params._N_z_bins(),0);
                So.message_screen("Computing comoving distances");
        if(this->params._sys_of_coord_g()==1 ||this->params._sys_of_coord_g()==2 )
          c_Cf.Comoving_distance_tabulated(Z_MIN,Z_MAX, (void *)&this->params.s_cosmo_pars,vzz,vrc);
        So.DONE();
        // **************************************************************************
        // Derived parameters associated to
                //  fftw_functions.set_healpix_pars(params._Healpix_resolution());
        // **************************************************************************
        // If applies, give a first estimate of mean number density from a box
        // in case we do not use random catalog                                                    *
        //If a random catalog is used, set this numer to 1
        //and use the nmbar tabulated in the catalogs or computed in this code
        mean_density=1.0;
        if(false==this->params._use_random_catalog())
          {
            So.message_screen("Using particles in a box.");
            mean_density=static_cast<real_prec>(this->N_galaxy)/pow(this->params._Lbox(),3);
            So.message_screen("Mean Number density = ",mean_density," (Mpc/h)^(-3)");
          }
        // *************************************************************************
        // If nbar is not tabulated, compute it from the random catalog
        bool compute_dndz=false;
        if(true==this->params._use_random_catalog() && false==params._nbar_tabulated())
          compute_dndz=true;
        // *************************************************************************
        // Give a first estimate of the alpha-parameter                                            *
        real_prec alpha_0=1.0;
        if(true==this->params._use_random_catalog())
          alpha_0 = ((real_prec)this->N_galaxy)/((real_prec)this->N_random);
        // This structure will be used in 1P_this->params._statistics()
        s_dndz s_dndz_params;
        if(this->params._use_random_catalog()==true && params._nbar_tabulated()==false)
          s_dndz_params={
            this->random_cat.Halo,
            rc_n_columns,
            alpha_0,
            this->params._nbar_tabulated(),
            compute_dndz,
            this->params._constant_depth(),
            vzz,
            vrc,
            this->params._N_dndz_bins(),
            this->params._new_N_dndz_bins(),
            this->params._redshift_min_sample(),
            this->params._redshift_max_sample(),
            this->params._area_survey(),
            this->params._sys_of_coord_r(),
            this->params._i_coord1_r(),
            this->params._i_coord2_r(),
            this->params._i_coord3_r(),
                    fftw_functions.area_pixel,
                    fftw_functions.npixels,
                    fftw_functions.nside,
            file_dndz
          } ;
        // This should only be defined if we do not use randoms with nbar tabulated.
        // IN FFTWFUNCTIONS ALL CALLS TO HEALPIX AND MAP-DEFINED VECTORS ARE COMMENTED
        vector<gsl_real> z_v;
        vector<gsl_real> dndz_v;
        vector< vector<gsl_real> > dndz_matrix;
        // If nbar is not tabulated, Compute a smoothed version of dN/dz from randoms to get nbar  *
        if(true==this->params._use_random_catalog() && false==params._nbar_tabulated())
          {
            z_v.resize(params._new_N_dndz_bins(),0);
            dndz_v.resize(z_v.size(),0);
            dndz_matrix.resize(z_v.size());
                    for(int i=0;i<dndz_matrix.size(); ++i)dndz_matrix[i].resize(fftw_functions.npixels,0);
            c_Op.dndz((void *)&s_dndz_params,z_v, dndz_v, dndz_matrix);
          }
        // *************************************************************************
        So.message_screen("Setting data in structure for TRACERS");
        s_data_structure s_data_struct_g={
          this->tracer_cat.Halo,
          gc_n_columns,
          this->params._sys_of_coord_g(),
          "data",
          mean_density,
          this->params._nbar_tabulated(),
          compute_dndz,
          z_v,
          dndz_v,
          dndz_matrix
        };
        So.DONE();
        So.message_screen("Freeing memmory prop in ", __PRETTY_FUNCTION__);
        this->tracer_cat.Halo.clear();
        this->tracer_cat.Halo.shrink_to_fit();
        So.DONE();
        // *************************************************************************
        // Allocate structure with random catalogue and information of dN/dz                       *
        // *************************************************************************
        So.message_screen("Setting data in structure for RANDOMS");
        s_data_structure s_data_struct_r={
          this->random_cat.Halo,
          rc_n_columns,
          this->params._sys_of_coord_r(),
          "random",
          mean_density,
          this->params._nbar_tabulated(),
          compute_dndz,
          z_v,
          dndz_v,
          dndz_matrix
        };
        So.DONE();
        So.message_screen("Freeing memmory prop in ", __PRETTY_FUNCTION__);
        if(false==this->params._get_window_matrix())
          {
            this->random_cat.Halo.clear();
            this->random_cat.Halo.shrink_to_fit();
          }
        So.DONE();
        // *****************************************************************************************
        // Allocate a strucuture
                s_p_box.npixels=fftw_functions.npixels;
                s_p_box.nside=fftw_functions.nside;
        s_p_box.file_dndz=file_dndz;
        // **********************************************************************************
        // Estimate of the mean number density
        //  cout<<"Maximum Nfft allowed by mean density = "<<(int)(2.*pow(N_galaxy, 1./3.))<<endl;
        real_prec Lside=this->params._Lbox();
        mean_density=this->N_galaxy/pow(Lside,3);  //This is  raw estimate!!
        if(false==this->params._use_random_catalog())
          mean_density=this->N_galaxy/pow(Lside,3);
        else
          mean_density=1.0;
        // *****************************************************************************************
        // Transforming to cartessian coord.- and searching for box side lenght.
        if(this->params._sys_of_coord_g()!=0)
          {
            So.message_screen("Transform to cartesian coordinates in tracer catalogue ");
                    fftw_functions.cart_coordinates(&s_p_box,&s_data_struct_g);
            So.DONE();
          }
        if(true==this->params._use_random_catalog())
          {
            if( this->params._sys_of_coord_r()!=0)
              {
            So.message_screen("Transform to cartesian coordinates in random catalogue ");
                        fftw_functions.cart_coordinates(&s_p_box,&s_data_struct_r);
                So.DONE();
              }
          }
        // *****************************************************************************************
        // Determine size of box for the density interpolation and the Fourier transform:
        // New version: we do this in the same loop that convert to cartesian coords.
        // We then save other loop over the galaxies!
        // The side of the box computed from the catalog is a public variable of FFTW Lside_data.
        // Given the fact that we might want to have it fixed from the parameter file
        // we select the new Lside and pass it again as Lside
        if(true==params._new_Lbox())
          {
                    Lside=fftw_functions._Lbox_data();
            this->params.set_Lbox(Lside);
          }
                fftw_functions.resize_fftw_vectors();
        if(true==verbose)
                  fftw_functions.write_fftw_parameters();
        // ***********************************************************************************
        // Build interpolated galaxy density field
        if(this->params._statistics()=="Pk_y_ds")
          {
            So.message_screen("Creating galaxy density field on a Fourier grid...");
                    fftw_functions.get_power_moments_fourier_grid_ds_yam(&s_data_struct_g);
            So.DONE();
          }
        else
          {
            So.message_screen("Interpolating galaxy density field on a grid");
#ifdef _USE_VECTORIZED_GRID_ASSIGNMENT_
                    fftw_functions.get_interpolated_density_field_old(&s_data_struct_g);
#else
                    fftw_functions.get_interpolated_density_field(&s_data_struct_g,false,"any");
#endif
            So.DONE();
          }
        // ***********************************************************************************
        // Build interpolated random density field
        if(true==this->params._use_random_catalog())
          {
            if(this->params._statistics()=="Pk_y_ds")
              {
            So.message_screen("Creating random density field on a Fourier grid");
                        fftw_functions.get_power_moments_fourier_grid_ds_yam(&s_data_struct_r);
            So.DONE();
              }
            else
              {
            So.message_screen("Interpolating random density field on a grid");
#ifdef _USE_VECTORIZED_GRID_ASSIGNMENT_
                        fftw_functions.get_interpolated_density_field_old(&s_data_struct_r);
#else
                        fftw_functions.get_interpolated_density_field(&s_data_struct_r,false,"any");
#endif
            So.DONE();
              }
                    // ****************************************************************************************************
            if(true==this->params._get_window_matrix() && true==this->params._nbar_tabulated())
              {
#ifdef _FULL_VERBOSE_
            So.message_screen("Computing mixing matrix");
#endif
                this->get_window_matrix_multipole();
              }
            // ****************************************************************************************************
          }
        else
          {
            real_prec vol=pow(Lside,3);
                    fftw_functions.raw_sampling(vol);
          }
                fftw_functions.get_parameters_estimator(verbose);
                fftw_functions.get_fluctuation();
          }
        else if (this->params._input_type()=="delta_grid" || this->params._input_type()=="density_grid"  ) // Else, we read the delta from this input file.
          {
        So.message_screen("Starting density field on a grid");
        real_prec ngal_new;
        bool measure_diff=false;

        if(false==this->params._measure_cross() && false==measure_diff) // If no crossed power, read per default theparams._delta_grid_file()
          {
            fftw_array<float> dummy(this->params._NGRID());
            switch(this->params._measure_cross_from_1())
              { //choose the file to get the auto power from
              case(1):
            this->File.read_array(this->params._delta_grid_file(), dummy,this->params._NGRID());
            break;
              case(2):
            this->File.read_array(this->params._delta_grid_file2(), dummy,this->params._NGRID());
            break;
              case(3):
            this->File.read_array(this->params._delta_grid_file3(), dummy,this->params._NGRID());
            break;
              case(4):
            this->File.read_array(this->params._delta_grid_file4(), dummy,this->params._NGRID());
            break;
              }
                    fftw_functions.data_g.clear();
                    fftw_functions.data_g.shrink_to_fit();
                    fftw_functions.data_g.resize(this->params._NGRID(),0);
            if (this->params._input_type()=="delta_grid")
              {
#ifdef _USE_OMP_
#pragma omp parallel
#endif
            for(ULONG i=0;i<this->params._NGRID();++i)
                          fftw_functions.data_g[i]=static_cast<real_prec>(dummy[i]);
            ngal_new=this->params._ngal_delta();
              }
            else if (this->params._input_type()=="density_grid")
              {
            ngal_new=0;
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new)
#endif
            for(ULONG i=0;i<this->params._NGRID();++i)
              ngal_new+=static_cast<real_prec>(dummy[i]);
            real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
            for(ULONG i=0;i<this->params._NGRID();++i)
                          fftw_functions.data_g[i]=(static_cast<real_prec>(dummy[i])/static_cast<real_prec>(nmean))-1.;
            this->params.set_ngal_delta(ngal_new);
                        fftw_functions.set_n_gal(ngal_new);
              }
                    real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
                    fftw_functions.set_normal_power(pow(factor,-2));
                    fftw_functions.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);
            if(true==verbose)
              {
                        fftw_functions.write_fftw_parameters();
#ifdef _FULL_VERBOSE_
                        So.message_screen("Shot Noise =",fftw_functions.shot_noise);
#endif
              }
                    fftw_functions.resize_fftw_vectors();
          }
        else if(true==measure_diff)
          {
            fftw_array<float> dummy(this->params._NGRID());
            fftw_array<float> dummy2(this->params._NGRID());

            this->File.read_array(this->params._delta_grid_file(), dummy,this->params._NGRID());
            this->File.read_array(this->params._delta_grid_file2(), dummy2,this->params._NGRID());
                    fftw_functions.data_g.resize(this->params._NGRID(),0);
            ULONG ngal_new2=0;
            ULONG ngal_new1=0;
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new1)
#endif
            for(ULONG i=0;i<this->params._NGRID();++i)
              ngal_new1+=static_cast<real_prec>(dummy[i]);
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new2)
#endif
            for(ULONG i=0;i<this->params._NGRID();++i)
              ngal_new2+=static_cast<real_prec>(dummy2[i]);
            real_prec nmean1=static_cast<real_prec>(ngal_new1)/static_cast<real_prec>(this->params._NGRID());
            real_prec nmean2=static_cast<real_prec>(ngal_new2)/static_cast<real_prec>(this->params._NGRID());
                    fftw_functions.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new1);
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
            for(ULONG i=0;i<this->params._NGRID();++i)
                      //	    fftw_functions.data_g[i]=(static_cast<real_prec>(dummy[i])/static_cast<real_prec>(nmean1) - static_cast<real_prec>(dummy2[i])/static_cast<real_prec>(nmean2));///fftw_functions.shot_noise;
                      fftw_functions.data_g[i]=(static_cast<real_prec>(dummy[i]) - static_cast<real_prec>(dummy2[i])/static_cast<real_prec>(nmean2));///fftw_functions.shot_noise;
            this->params.set_ngal_delta(ngal_new1);
                    fftw_functions.set_n_gal(ngal_new1);
                    real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
                    fftw_functions.set_normal_power(pow(factor,-2));
                    fftw_functions.shot_noise=0;
            if(true==verbose)
                      fftw_functions.write_fftw_parameters();
                    fftw_functions.resize_fftw_vectors();
          }
        else  if(true==this->params._measure_cross()) // If no crossed power, read per default theparams._delta_grid_file()  // if we measure the cross, then
          {
                    fftw_functions.data_g.resize(this->params._NGRID(),0);
            fftw_array<float> dummy(this->params._NGRID());
            switch(this->params._measure_cross_from_1()){ //choose the file to get the auto power from
            case(1):
              this->File.read_array(this->params._delta_grid_file(), dummy,this->params._NGRID());
              break;
            case(2):
              this->File.read_array(this->params._delta_grid_file2(), dummy,this->params._NGRID());
              break;
            case(3):
              this->File.read_array(this->params._delta_grid_file3(), dummy,this->params._NGRID());
              break;
            case(4):
              this->File.read_array(this->params._delta_grid_file4(), dummy,this->params._NGRID());
              break;
            }
            if (this->params._input_type()=="delta_grid")
              {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
                        for(ULONG i=0;i<this->params._NGRID();++i)fftw_functions.data_g[i]=static_cast<real_prec>(dummy[i]);
            ngal_new=this->params._ngal_delta();
              }
            else if (this->params._input_type()=="density_grid")
              {
            ngal_new=0;
            for(ULONG i=0;i<this->params._NGRID();++i)ngal_new+=static_cast<real_prec>(dummy[i]);
            real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
            for(ULONG i=0;i<this->params._NGRID();++i)
                          fftw_functions.data_g[i]=(static_cast<real_prec>(dummy[i])/static_cast<real_prec>(nmean))-1.0;
              }
                    fftw_functions.shot_noise=0;
            if(true==this->params._SN_correction())
                      fftw_functions.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);
                    So.message_screen("Shot Noise =",fftw_functions.shot_noise);
            switch(this->params._measure_cross_from_2())
              { //choose the file to get the auto power from
              case(1):
            this->File.read_array(this->params._delta_grid_file(), dummy,this->params._NGRID());
            break;
              case(2):
            this->File.read_array(this->params._delta_grid_file2(), dummy,this->params._NGRID());
            break;
              case(3):
            this->File.read_array(this->params._delta_grid_file3(), dummy, this->params._NGRID());
            break;
              case(4):
            this->File.read_array(this->params._delta_grid_file4(), dummy, this->params._NGRID());
            break;
              }
                    fftw_functions.data_gp.resize(this->params._NGRID(),0);
            if (this->params._input_type()=="delta_grid")
              {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
            for(ULONG i=0;i<this->params._NGRID();++i)
                          fftw_functions.data_gp[i]=static_cast<real_prec>(dummy[i]);
            ngal_new=this->params._ngal_delta();
              }
            else if (this->params._input_type()=="density_grid")
              {
            ngal_new=0;
                        //                  for(ULONG i=0;i<this->params._NGRID();++i)fftw_functions.data_gp[i]=static_cast<real_prec>(dummy[i]);

#ifdef _KONV_
            ULONG ntt=this->params._NGRID_h();
            FileOutput File;
            vector<real_prec>kernel(ntt,0);
            File.read_array("/net/vaina/scratch/balaguera/data/Numerics/IACmocks/ANALYSIS/BAM/Output_Minerva_R220_III/Bam_Kernel.dat",kernel);
                        convolvek(this->params._Nft(),fftw_functions.data_gp, kernel,fftw_functions.data_gp);
#endif
            //                 for(ULONG i=0;i<this->params._NGRID();++i)
                        //                    ngal_new+=fftw_functions.data_gp[i];
            //                  real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());
            //#pragma omp parallel for
            //                  for(ULONG i=0;i<this->params._NGRID();++i)
                        //                    fftw_functions.data_gp[i]=(static_cast<real_prec>(fftw_functions.data_gp[i])/static_cast<real_prec>(nmean))-1.0;

            this->So.message_warning("In PowerSpectrumF.cpp I have manually set that the field2 is already a delta. This can be solved if I define a new variable input_type for the second field in the cross power");
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
            for(ULONG i=0;i<this->params._NGRID();++i)
                          fftw_functions.data_gp[i]=static_cast<real_prec>(dummy[i]);
              }
            // Here we find 1+delta in the grid
                    real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
                    fftw_functions.set_normal_power(pow(factor, -2));
            //IF IT IS DM
                    fftw_functions.shot_noise2=0;//static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);
            if(true==this->params._SN_correction())
              {
                        So.message_screen("Shot noise 1 =", fftw_functions.shot_noise);
                        So.message_screen("Shot noise 2 =", fftw_functions.shot_noise2);
              }
            else
              So.message_screen("No SN correction");

            if(true==verbose)
                      fftw_functions.write_fftw_parameters();

                    fftw_functions.resize_fftw_vectors();
          }
          }
        // *****************************************************************************************
        // *****************************************************************************************
        // *****************************************************************************************
        // WELCOME TO FOURIER SPACE
        // *****************************************************************************************
        if(this->params._statistics()=="Pk_fkp" || this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb"  || this->params._statistics()=="Pk_ybc"   || this->params._statistics()=="Pk_ysc" ||  this->params._statistics()=="Pk_y_ds")
          {
        // FFTW and estimates of power spectrum                                                    *
        kvector_data.clear();
        kvector_data.shrink_to_fit();
        kvector_window.clear();
        kvector_window.shrink_to_fit();
        if("linear" == this->params._type_of_binning())
          {
            for(int i=0;i<this->params._d_Nnp_data();i++)
              kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));

            for(int i=0;i<this->params._d_Nnp_window();i++)
                      kvector_window.push_back(this->params._d_kmin()+fftw_functions.DeltaK_window*(i+0.5));
          }
        else if("log"==this->params._type_of_binning())
          {
            for(int i=0;i<kvector_data.size();i++)
              kvector_data.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
            for(int i=0;i<kvector_window.size();i++)
              kvector_window.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
          }
        for(int i=0;i<this->params._d_Nnp_data();i++)
          kvector_data2d.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
        for(int i=0;i<params._N_mu_bins();i++)
          muvector.push_back(-1.0+this->params._d_Deltamu()*(i+0.5));
        // *****************************************************************************
        // Resize arrays for P(k), and 2d P(k). Compute and write to file
        this->pk0.clear();
        this->pk0.shrink_to_fit();
        this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
        //#ifdef _WRITE_MULTIPOLES_
        this->pk2.resize(this->params._d_Nnp_data(),0); //Quadrupole
        this->pk4.resize(this->params._d_Nnp_data(),0); //Hexadecapole
        //#endif
        this->pk_w.clear();
        this->pk_w.shrink_to_fit();
        this->pk_w.resize(this->params._d_Nnp_window(),0); //W(k)
        this->modes_g.clear();
        this->modes_g.shrink_to_fit();
        this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance
        //#ifdef _WRITE_2DPOWER_
        this->pkk.resize(this->params._d_Nnp_data());
        this->pmk.resize(params._N_mu_bins());
        for(int i=0;i<this->params._d_Nnp_data();i++)this->pkk[i].resize(this->params._d_Nnp_data(),0);
        for(int i=0;i<params._N_mu_bins();i++)this->pmk[i].resize(this->params._d_Nnp_data(),0);
        //#endif
        this->sigma_fkp.clear();
        this->sigma_fkp.shrink_to_fit();
        this->sigma_fkp.resize(this->params._d_Nnp_data(),0);
        // ****************************************************************************
        // Get power spectrum and more
        if(this->params._statistics()=="Pk_fkp")
          {
                    fftw_functions.get_power_spectrum_fkp(this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);
            sigma_y_l2.resize(this->params._d_Nnp_data(),0);
            sigma_y_l4.resize(this->params._d_Nnp_data(),0);
            if(true==params._FKP_error_bars())
              {
            So.message("Computing FKP error bars");
                        fftw_functions.get_fkp_error_bars(&s_data_struct_r, kvector_data, this->pk0, this->modes_g, this->sigma_fkp);
              }

#ifdef _USE_GNUPLOT_POWER_
                        this->gp.plot_power_spectrum(this->kvector_data,this->pk0);
#endif

                }
                  else if(this->params._statistics()=="Pk_yb" || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_y_ds" || this->params._statistics()=="Pk_ysc" )
                  fftw_functions.get_power_spectrum_yamamoto(this->pk0,this->pk2,this->pk4,this->modes_g);

        //MISSINGN ERROR BARS FROM YAMAMOTO HERE.
          }
        // Estimates of Bispectrum. Using the DFT already done for P(k)
        else if(this->params._statistics()=="Bk_fkp")
          {
        if(this->params._type_of_binning()=="linear")
          for(int i=0;i<this->params._d_Nnp_data();i++)
            kvector_data_b.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5)); //Oficcial binning
        else
          if(this->params._type_of_binning()=="log"){
            for(int i=0;i<this->params._d_Nnp_data();i++)
              kvector_data_b.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
          }
        bispectrum.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());
        sn_bispectrum.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());
        modes_tri.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());

                fftw_functions.get_bispectrum_fkp('d', &s_p_box, bispectrum, sn_bispectrum, modes_tri);
        File.write_to_file(file_bispectrum,kvector_data_b,bispectrum,modes_tri);
          }

        // Estimates of Bispectrum for FKP using fast version
        else if(this->params._statistics()=="Bk_fkp_fast")
          {
                //for(int i=0;i<fftw_functions.Nshells_bk;i++)kvector_data_b.push_back(this->params._d_DeltaK_data()*(i+0.5)); //Oficcial binning
        this->pk0.resize(this->params._d_Nnp_data(),0);
                for(int i=0;i<fftw_functions.Nshells_bk;i++)
          kvector_data_b.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5)); //Jennifer's binning
                bispectrum.resize(fftw_functions.Nshells_bk*fftw_functions.Nshells_bk*fftw_functions.Nshells_bk,0);
                sn_bispectrum.resize(fftw_functions.Nshells_bk*fftw_functions.Nshells_bk*fftw_functions.Nshells_bk,0);
                modes_tri.resize(fftw_functions.Nshells_bk*fftw_functions.Nshells_bk*fftw_functions.Nshells_bk,0);
                fftw_functions.get_power_spectrum_for_bispectrum(&s_p_box, this->pk0);
                fftw_functions.get_bispectrum_fkp_fast(&s_p_box,this->pk0,bispectrum,modes_tri,file_bispectrum);
          }
#ifndef _WRITE_MULTIPOLES_
        write_power_and_modes();
#else
        write_power_spectrum();
#endif
#if defined(_USE_MASS_CUTS_PK_) || defined (_USE_MASS_BINS_PK_)
      }
#endif
      }






// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// This function is to be read from the cosmicatlas.cpp main function: verbose is to show detailed information, mcut is to force the analysis to have a minium cut in a given property
  // depending on w


void PowerSpectrumF::compute_window_function(){

    time_t start;
    time (&start);

#ifdef _USE_OMP_
    int NTHREADS=_NTHREADS_;
    omp_set_num_threads(NTHREADS);
#endif
string file_pow=this->file_power;

#ifdef _JPAS_   // this moves the position of the men number denisty in the random prepared for jpas staged
        int i_Nw_ori_r=this->params._i_mean_density_r();
        int i_Nw_ori_g=this->params._i_mean_density_g();
            int new_col_nbar_r=i_Nw_ori_r;
            this->params.set_i_mean_density_r(new_col_nbar_r);
            int new_col_nbar_g=i_Nw_ori_g;
            this->params.set_i_mean_density_g(new_col_nbar_g);
#endif

#ifdef _FULL_VERBOSE_
        if(this->params._statistics()=="Pk_fkp")So.welcome_message();
        if(this->params._statistics()=="Bk_fkp")So.welcome_message_bispectrum();
        if(this->params._statistics()=="Bk_fkp_fast")So.welcome_message_bispectrum_fast();
        if(this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb" || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ysc" || this->params._statistics()=="Pk_y_ds")So.welcome_message_yama();
#endif

        if(2==this->params._sys_of_coord_g())
          So.write_cosmo_parameters((void *)&this->params.s_cosmo_pars);
        // ***********************************************************
        // Define some structures here
        s_parameters_box s_p_box;
        // ***********************************************************
        // Add random and galaxy catalogues
        this->File.input_type=this->params._input_type();

        this->add_random_catalogue();

        vector<gsl_real>vzz(params._N_z_bins(),0);
        vector<gsl_real>vrc(params._N_z_bins(),0);
                So.message_screen("Computing comoving distances");
        if(this->params._sys_of_coord_g()==1 ||this->params._sys_of_coord_g()==2 )
          c_Cf.Comoving_distance_tabulated(Z_MIN,Z_MAX, (void *)&this->params.s_cosmo_pars,vzz,vrc);
        So.DONE();
            So.message_screen("Using particles in a box.");
            mean_density=static_cast<real_prec>(this->N_galaxy)/pow(this->params._Lbox(),3);
        So.message_screen("Mean Number density = ",mean_density," (Mpc/h)^(-3)");

        // *************************************************************************
        // If nbar is not tabulated, compute it from the random catalog
        bool compute_dndz=false;
        if(true==this->params._use_random_catalog() && false==params._nbar_tabulated())
          compute_dndz=true;

        // *************************************************************************
        // Give a first estimate of the alpha-parameter                                            *
        real_prec alpha_0=1.0;
        if(true==this->params._use_random_catalog())
          alpha_0 = ((real_prec)this->N_galaxy)/((real_prec)this->N_random);


        // This structure will be used in 1P_this->params._statistics()
        s_dndz s_dndz_params;
        if(this->params._use_random_catalog()==true && params._nbar_tabulated()==false)
          s_dndz_params={
                 this->random_cat.Halo,
                 rc_n_columns,
                 alpha_0,
                 this->params._nbar_tabulated(),
                 compute_dndz,
                 this->params._constant_depth(),
                 vzz,
                 vrc,
                 this->params._N_dndz_bins(),
                 this->params._new_N_dndz_bins(),
                 this->params._redshift_min_sample(),
                 this->params._redshift_max_sample(),
                 this->params._area_survey(),
                 this->params._sys_of_coord_r(),
                 this->params._i_coord1_r(),
                 this->params._i_coord2_r(),
                 this->params._i_coord3_r(),
                 fftw_functions.area_pixel,
                 fftw_functions.npixels,
                 fftw_functions.nside,
                 file_dndz
          } ;



        // This should only be defined if we do not use randoms with nbar tabulated.
        // IN FFTWFUNCTIONS ALL CALLS TO HEALPIX AND MAP-DEFINED VECTORS ARE COMMENTED
        vector<gsl_real> z_v;
        vector<gsl_real> dndz_v;
        vector< vector<gsl_real> > dndz_matrix;
        // If nbar is not tabulated, Compute a smoothed version of dN/dz from randoms to get nbar  *
        if(true==this->params._use_random_catalog() && false==params._nbar_tabulated())
          {
            z_v.resize(params._new_N_dndz_bins(),0);
            dndz_v.resize(z_v.size(),0);
            dndz_matrix.resize(z_v.size());
            for(int i=0;i<dndz_matrix.size(); ++i)dndz_matrix[i].resize(fftw_functions.npixels,0);
            c_Op.dndz((void *)&s_dndz_params,z_v, dndz_v, dndz_matrix);
          }

        // *************************************************************************
        // Allocate structure with random catalogue and information of dN/dz                       *
        // *************************************************************************
        So.message_screen("Setting data in structure for RANDOMS");
        s_data_structure s_data_struct_r={
      this->random_cat.Halo,
      rc_n_columns,
      this->params._sys_of_coord_r(),
      "random",
      mean_density,
      this->params._nbar_tabulated(),
      compute_dndz,
      z_v,
      dndz_v,
      dndz_matrix
        };
        So.DONE();
        s_p_box.npixels=fftw_functions.npixels;
        s_p_box.nside=fftw_functions.nside;
        s_p_box.file_dndz=file_dndz;

        // **********************************************************************************
        // Estimate of the mean number density
        //  cout<<"Maximum Nfft allowed by mean density = "<<(int)(2.*pow(N_galaxy, 1./3.))<<endl;
        real_prec Lside=this->params._Lbox();
        mean_density=1.0;

        // *****************************************************************************************
        // Transforming to cartessian coord.- and searching for box side lenght.

        if( this->params._sys_of_coord_r()!=0)
      {
            So.message_screen("Transform to cartesian coordinates in random catalogue ");
            fftw_functions.cart_coordinates(&s_p_box,&s_data_struct_r);
        So.DONE();
      }
        if(true==params._new_Lbox())
          {
            Lside=fftw_functions._Lbox_data();
            this->params.set_Lbox(Lside);
          }
        fftw_functions.resize_fftw_vectors();


#ifdef _FULL_VERBOSE_
        fftw_functions.write_fftw_parameters();
#endif

    if(true==this->params._nbar_tabulated())
      {
#ifdef _FULL_VERBOSE_
            So.message_screen("Computing mixing matrix");
#endif
        this->get_window_matrix_multipole();
      }

}


// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

// Used specifically in case we supply grids 1+delta1 and 1+delta2 and we want to compute the auto and cross power
// threof
 void PowerSpectrumF::compute_power_spectrum_grid(const vector<real_prec> &data_in, bool write_to_file)
 {
#ifdef _VERBOSE_POWER_
   this->So.enter(__PRETTY_FUNCTION__);
#endif

#ifdef _USE_OMP_
   int NTHREADS=_NTHREADS_;
   omp_set_num_threads(NTHREADS);
#endif

   this->fftw_functions.resize_fftw_vectors();

   real_prec ngal_new,nmean;
   real_prec vol = static_cast<real_prec>(pow(this->params._Lbox(),3));

   // if delta  = rho - mean, (with Ngal given from par file) use normal=Ngal²/Vol (i.e, constructing delta from a catalog)
   // if delta = rho/mean -1, use normal = Ncells²/Vol (i.e, givng delta from outside.
   if(this->params._input_type()=="density_grid")
     {

       ngal_new=get_nobjects(data_in);
       this->params.set_ngal_delta(ngal_new);
       this->fftw_functions.set_n_gal(ngal_new);
       nmean=static_cast<double>(ngal_new)/static_cast<double>(this->params._NGRID());
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
       for(ULONG i=0;i<this->params._NGRID();++i)
         this->fftw_functions.data_g[i]=static_cast<real_prec>(data_in[i])-static_cast<real_prec>(nmean);
       this->fftw_functions.set_normal_power(static_cast<double>((static_cast<double>(ngal_new)/static_cast<double>(vol))*static_cast<double>(ngal_new)));
     }
   else if(this->params._input_type()=="delta_grid")
     {
       ngal_new=1.0;
       this->params.set_ngal_delta(ngal_new);
       this->fftw_functions.set_n_gal(ngal_new);
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
       for(ULONG i=0;i<this->params._NGRID();++i)
         this->fftw_functions.data_g[i]=data_in[i];
       this->fftw_functions.set_normal_power(static_cast<real_prec>(this->params._NGRID())*static_cast<real_prec>(this->params._NGRID())/static_cast<real_prec>(vol));
     }

#ifdef _FULL_VERBOSE_POWER_
   if(ngal_new>1)
     So.message_screen("Number of tracers in input density field = ",ngal_new);
   So.message_screen("Normalization of power = ",fftw_functions._normal_power());
#endif
   this->fftw_functions.set_shot_noise(vol/static_cast<real_prec>(ngal_new));
   this->shot_noise=fftw_functions._shot_noise();
#ifdef _FULL_VERBOSE_POWER_
   if(true==this->params._SN_correction())
     So.message_screen("Poisson Shot noise = ",fftw_functions.shot_noise);
   else
     So.message_screen("Poisson Shot noise (not applied) = ",fftw_functions.shot_noise);
#endif

   kvector_data.resize(this->params._d_Nnp_data(), 0);
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
   for(ULONG i=0;i<this->params._d_Nnp_data();i++)
     this->kvector_data[i]=this->params._d_kmin()+(i+0.5)*this->params._d_DeltaK_data();

   this->pk0.resize(this->params._d_Nnp_data(),0);
   this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance

   fftw_functions.power_spectrum(this->pk0,this->modes_g);

   if(true==write_to_file)
     this->write_power_and_modes();

#ifdef _USE_GNUPLOT_POWER_
   this->gp.plot_power_spectrum(this->kvector_data,this->pk0);
#endif

 }//closes memmber function


 // ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

    // This method has as input the tracer catalog to measure the power once it has read before and outside the class
    // This is meant for the case in which NO RANDOMS ARE USED AND IS NOT READY TO USE MASS CUTS

    // tHIS ALSO IS MEANT FO RTHE OPTION catalog
void PowerSpectrumF::compute_power_spectrum(bool verbose, vector<s_Halo>& tracer_cat){


#ifdef _VERBOSE_POWER_
            this->So.enter(__PRETTY_FUNCTION__);
#endif

      time_t start;
      time (&start);

#ifdef _USE_OMP_
      int NTHREADS=_NTHREADS_;
      omp_set_num_threads(NTHREADS);
#endif


#ifdef _MASS_WEIGHT_POWER_
      if(true==this->params._weight_with_mass())
    So.message_screen("Measuring the Mass-power spectrum");
#elif defined(_USE_MASS_CUTS_PK_)
      So.message_screen("Measuring power spectrum in mass cuts");
#endif

      string file_pow=this->file_power;


#ifdef _USE_MASS_CUTS_PK_
      vector<real_prec>mass_cuts;

#ifdef _SET_GLOBAL_MASS_CUT_
#ifdef _USE_VMAX_AS_PRIMARY_OBSERVABLE_
      So.message_screen("Using one global Vmax-cut at Vmax = ",MINIMUM_PROP_CUT," km/s");
#elif defined _USE_MASS_AS_OBSERVABLE_
      So.message_screen("Using one global Halo Mass-cut at M = ",MINIMUM_PROP_CUT, "Ms/h");
#endif


#else
      So.message_warning("Masss-cuts are defined in PowerSpectrumF::compute_power_spectrum");
#endif
      mass_cuts.clear();

      bool mcut=true;

      if(true==this->params._weight_with_mass())
    mcut=false;

      if(true==mcut)
    {
#ifdef _SET_GLOBAL_MASS_CUT_
      mass_cuts.push_back(MINIMUM_PROP_CUT);
#endif
    }
      else
    {
      mass_cuts.push_back(pow(10,this->params._LOGMASSmin()*this->params._MASS_units()));
    }


      for(int im=0; im< mass_cuts.size();++im)
    {
#endif

#ifdef _USE_MASS_CUTS_PK_
          fftw_functions.set_imcut(im);
      this->file_power=file_pow+"_masscut"+to_string(im);
#ifdef _SET_GLOBAL_MASS_CUT_
      this->file_power=file_pow+"_global_cut";
#endif

#endif
      if(true==verbose)
        {
          if(this->params._statistics()=="Pk_fkp")So.welcome_message();
          if(this->params._statistics()=="Bk_fkp")So.welcome_message_bispectrum();
          if(this->params._statistics()=="Bk_fkp_fast")So.welcome_message_bispectrum_fast();
          if(this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb" || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ysc" || this->params._statistics()=="Pk_y_ds")So.welcome_message_yama();
        }


      if( this->params._sys_of_coord_g()==2)
        So.write_cosmo_parameters((void *)&this->params.s_cosmo_pars);

      // Define some structures here
      s_parameters_box s_p_box;
      s_data_structure s_data_struct_r; // this is defiend here for the fkp error bars need the info from the randoms. So far at this point it is only defiend but not filled
      //


      // ***********************************************************
      // Add random and galaxy catalogues
      this->File.input_type=this->params._input_type();
      this->N_galaxy=tracer_cat.size();

      // ***********************************************************
      // Tabulate r-z relation if radial coordinate is redshift
      vector<gsl_real>vzz;
      vector<gsl_real>vrc;
      if( this->params._sys_of_coord_g()==1 || this->params._sys_of_coord_g()==2 )
        {
          vzz.resize(params._N_z_bins(),0);
          vrc.resize(params._N_z_bins(),0);
          c_Cf.Comoving_distance_tabulated(0,1.0, (void *)&this->params.s_cosmo_pars,vzz,vrc);
        }

      // **************************************************************************
      // Derived parameters associated to
          //  fftw_functions.set_healpix_pars(params._Healpix_resolution());

      // **************************************************************************
      // If applies, give a first estimate of mean number density from a box
      // in case we do not use random catalog                                                    *
      //If a random catalog is used, set this numer to 1
      //and use the nmbar tabulated in the catalogs or computed in this code
      mean_density=1.0;

      if(false==this->params._use_random_catalog())
        {
          if(true==verbose)
        So.message_screen("Using particles in a box.");

          mean_density=static_cast<real_prec>(this->N_galaxy)/pow(this->params._Lbox(),3);
          if(true==verbose)
        So.message_screen("Mean Number density = ",mean_density," (Mpc/h)^(-3)");
        }


      // *************************************************************************
      // If nbar is not tabulated, compute it from the random catalog
      bool compute_dndz=false;
      if(true==this->params._use_random_catalog() && false== this->params._nbar_tabulated())
        compute_dndz=true;

      // *************************************************************************
      // Give a first estimate of the alpha-parameter                                            *
      real_prec alpha_0=1.0;
      if(true==this->params._use_random_catalog())
        alpha_0 = ((real_prec)this->N_galaxy)/((real_prec)this->N_random);


      // This structure will be used in 1P_this->params._statistics()
      s_dndz s_dndz_params;
      if(this->params._use_random_catalog()==true && params._nbar_tabulated()==false)
        s_dndz_params={
          this->random_cat.Halo,
          this->rc_n_columns,
          alpha_0,
          params._nbar_tabulated(),
          compute_dndz,
          params._constant_depth(),
          vzz,
          vrc,
          params._N_dndz_bins(),
          params._new_N_dndz_bins(),
          this->params._redshift_min_sample(),
          this->params._redshift_max_sample(),
          this->params._area_survey(),
          this->params._sys_of_coord_r(),
          this->params._i_coord1_r(),
          this->params._i_coord2_r(),
          this->params._i_coord3_r(),
              fftw_functions.area_pixel,
              fftw_functions.npixels,
              fftw_functions.nside,
          file_dndz
        };


      // This should only be defined if we do not use randoms with nbar tabulated.
      // IN FFTWFUNCTIONS ALL CALLS TO HEALPIX AND MAP-DEFINED VECTORS ARE COMMENTED
      vector<gsl_real> z_v;
      vector<gsl_real> dndz_v;
      vector< vector<gsl_real> > dndz_matrix;
      // If nbar is not tabulated, Compute a smoothed version of dN/dz from randoms to get nbar  *
      if(this->params._use_random_catalog()==true && params._nbar_tabulated()==false)
        {
          z_v.resize(this->params._new_N_dndz_bins(),0);
          dndz_v.resize(z_v.size(),0);
          dndz_matrix.resize(z_v.size());
              for(int i=0;i<dndz_matrix.size(); ++i)dndz_matrix[i].resize(fftw_functions.npixels,0);
          c_Op.dndz((void *)&s_dndz_params,z_v, dndz_v, dndz_matrix);
        }
      // *************************************************************************

      s_data_structure s_data_struct_g={
        this->tracer_cat.Halo,
        gc_n_columns,
        this->params._sys_of_coord_g(),
        "data",
        mean_density,
        params._nbar_tabulated(),
        compute_dndz,
        z_v,
        dndz_v,
        dndz_matrix
      };
      // *****************************************************************************************
      // Allocate a strucuture
      // to be passed to the class member functions. We pass only those parameters
      // that were not passed through the set_pars method.

      s_p_box={
        vzz,
        vrc,
            fftw_functions.npixels,
            fftw_functions.nside,
        file_dndz,
      };


      // *****************************************************************************************
      // Transforming to cartessian coord.- and searching for box side lenght.
      if(this->params._sys_of_coord_g()!=0)
        {
#ifdef _VERBOSE_POWER_
              So.message_screen("Transform to cartesian coordinates in tracer catalogue");
#endif
              fftw_functions.cart_coordinates(&s_p_box,&s_data_struct_g);
          So.DONE();
        }
      s_data_struct_g.properties=tracer_cat;

      // *****************************************************************************************
      // Determine size of box for the density interpolation and the Fourier transform:
      // New version: we do this in the same loop that convert to cartesian coords.
      // We then save other loop over the galaxies!
      // The side of the box computed from the catalog is a public variable of FFTW Lside_data.
      // Given the fact that we might want to have it fixed from the parameter file
      // we select the new Lside and pass it again as Lside
      real_prec Lside=this->params._Lbox();
      if(this->params._new_Lbox())
           this->params.set_Lbox(fftw_functions._Lbox_data());
          fftw_functions.resize_fftw_vectors();
      // **********************************************************************************
      // Estimate of the mean number density
      //  cout<<"Maximum Nfft allowed by mean density = "<<(int)(2.*pow(N_galaxy, 1./3.))<<endl;
      mean_density=this->N_galaxy/pow(Lside,3);  //This is  raw estimate!!
      if(false==this->params._use_random_catalog())
        mean_density=this->N_galaxy/pow(Lside,3);  else mean_density=1.0;

      if(true==verbose)
              fftw_functions.write_fftw_parameters();
      // ***********************************************************************************
      // Build interpolated galaxy density field
      if(this->params._statistics()=="Pk_y_ds")
        {
#ifdef _FULL_VERBOSE_
          So.message_screen("Creating galaxy density field on a Fourier grid...");
#endif
              fftw_functions.get_power_moments_fourier_grid_ds_yam(&s_data_struct_g);
          So.DONE();
        }
      else
        {
#ifdef _FULL_VERBOSE_
          So.message_screen("Interpolating galaxy density field on a grid");
#endif

#ifdef _USE_VECTORIZED_GRID_ASSIGNMENT_
              fftw_functions.get_interpolated_density_field_old(&s_data_struct_g);
#else
              fftw_functions.get_interpolated_density_field(&s_data_struct_g, false, "any");
#endif

#ifdef _FULL_VERBOSE_
          So.DONE();
#endif
        }
      // ***********************************************************************************
      // Build interpolated random density field
      real_prec vol=pow(Lside,3);
          fftw_functions.raw_sampling(vol);

      // **********************************************************************************
          fftw_functions.get_parameters_estimator( verbose);
      // **********************************************************************************
      // Build fluctuation                                                                       *
          fftw_functions.get_fluctuation();

      // *****************************************************************************************
      // *****************************************************************************************
      // *****************************************************************************************
      // *****************************************************************************************
      // *****************************************************************************************
      // *****************************************************************************************
      // WELCOME TO FOURIER SPACE
      // *****************************************************************************************
      if(this->params._statistics()=="Pk_fkp" || this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_yb"  || this->params._statistics()=="Pk_ybc"   || this->params._statistics()=="Pk_ysc" ||  this->params._statistics()=="Pk_y_ds")
        {

          // *****************************************************************************************
          // FFTW and estimates of power spectrum                                                    *
          // *****************************************************************************************

          kvector_data.clear();
          kvector_data.shrink_to_fit();
          kvector_window.clear();
          kvector_window.shrink_to_fit();

          if(this->params._type_of_binning()=="linear")
            {
          for(int i=0;i<this->params._d_Nnp_data();i++)
            kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
              for(int i=0;i<this->params._d_Nnp_window();i++)
                    kvector_window.push_back(this->params._d_kmin()+fftw_functions.DeltaK_window*(i+0.5));
        }
          else  if(this->params._type_of_binning()=="log")
        {
          for(int i=0;i<kvector_data.size();i++)
            kvector_data.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
              for(int i=0;i<kvector_window.size();i++)
            kvector_window.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
        }
          for(int i=0;i<this->params._d_Nnp_data();i++)
        kvector_data2d.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
          for(int i=0;i<params._N_mu_bins();i++)
        muvector.push_back(-1.0+this->params._d_Deltamu()*(i+0.5));

          // *****************************************************************************
          // Resize arrays for P(k), and 2d P(k). Compute and write to file
          this->pk0.clear();
          this->pk0.shrink_to_fit();
          this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
          //#ifdef _WRITE_MULTIPOLES_
          this->pk2.resize(this->params._d_Nnp_data(),0); //Quadrupole
          this->pk4.resize(this->params._d_Nnp_data(),0); //Hexadecapole
          //#endif
          this->pk_w.clear();
          this->pk_w.shrink_to_fit();
          this->pk_w.resize(this->params._d_Nnp_window(),0); //W(k)

          this->modes_g.clear();
          this->modes_g.shrink_to_fit();
          this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance

          //#ifdef _WRITE_2DPOWER_
          this->pkk.resize(this->params._d_Nnp_data());
          this->pmk.resize(params._N_mu_bins());
          for(int i=0;i<this->params._d_Nnp_data();i++)this->pkk[i].resize(this->params._d_Nnp_data(),0);
          for(int i=0;i<params._N_mu_bins();i++)this->pmk[i].resize(this->params._d_Nnp_data(),0);
          //#endif

          this->sigma_fkp.clear();
          this->sigma_fkp.shrink_to_fit();
          this->sigma_fkp.resize(this->params._d_Nnp_data(),0);

          // ****************************************************************************
          // Get power spectrum and more

          if(this->params._statistics()=="Pk_fkp")
        {
                  fftw_functions.get_power_spectrum_fkp(this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);
          sigma_y_l2.resize(this->params._d_Nnp_data(),0);
          sigma_y_l4.resize(this->params._d_Nnp_data(),0);
          if(true==params._FKP_error_bars())
            {
              So.message("Computing FKP error bars");
                      fftw_functions.get_fkp_error_bars(&s_data_struct_r, kvector_data, this->pk0, this->modes_g, this->sigma_fkp);
            }
        }
          else if(this->params._statistics()=="Pk_yb" || this->params._statistics()=="Pk_ybc" || this->params._statistics()=="Pk_ys" || this->params._statistics()=="Pk_y_ds" || this->params._statistics()=="Pk_ysc" )
        {
                  fftw_functions.get_power_spectrum_yamamoto(this->pk0,this->pk2,this->pk4,this->modes_g);
        }
          //MISSINGN ERROR BARS FROM YAMAMOTO HERE.

        }

      // Estimates of Bispectrum. Using the DFT already done for P(k)
      else if(this->params._statistics()=="Bk_fkp")
        {

          if(this->params._type_of_binning()=="linear")
        for(int i=0;i<this->params._d_Nnp_data();i++)
          kvector_data_b.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5)); //Oficcial binning
          else
        if(this->params._type_of_binning()=="log"){
          for(int i=0;i<this->params._d_Nnp_data();i++)
            kvector_data_b.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
        }
          bispectrum.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());
          sn_bispectrum.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());
          modes_tri.resize(this->params._Nft()*this->params._Nft()*this->params._Nft());

              fftw_functions.get_bispectrum_fkp('d', &s_p_box, bispectrum, sn_bispectrum, modes_tri);
          File.write_to_file(file_bispectrum,kvector_data_b,bispectrum,modes_tri);
        }

      // Estimates of Bispectrum for FKP using fast version
      else if(this->params._statistics()=="Bk_fkp_fast")
        {
              //for(int i=0;i<fftw_functions.Nshells_bk;i++)kvector_data_b.push_back(this->params._d_DeltaK_data()*(i+0.5)); //Oficcial binning

          this->pk0.resize(this->params._d_Nnp_data(),0);

              for(int i=0;i<fftw_functions.Nshells_bk;i++)
        kvector_data_b.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5)); //Jennifer's binning

              bispectrum.resize(fftw_functions.Nshells_bk*fftw_functions.Nshells_bk*fftw_functions.Nshells_bk,0);
              sn_bispectrum.resize(fftw_functions.Nshells_bk*fftw_functions.Nshells_bk*fftw_functions.Nshells_bk,0);
              modes_tri.resize(fftw_functions.Nshells_bk*fftw_functions.Nshells_bk*fftw_functions.Nshells_bk,0);
              fftw_functions.get_power_spectrum_for_bispectrum(&s_p_box, this->pk0);
              fftw_functions.get_bispectrum_fkp_fast(&s_p_box,this->pk0,bispectrum,modes_tri,file_bispectrum);

        }

      So.DONE();

#ifndef _WRITE_MULTIPOLES_
      write_power_and_modes();
#else
      write_power_spectrum();
#endif

#ifdef _USE_MASS_CUTS_PK_
    }
#endif


    }






// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************


// This tries to unify the functions compute_power_spectrum_bam_real_space and compute_power_spectrum_bam_redshift_space. This works. PLEASE EXPAND IT TO ASK FOR MASS OR VMAX BINS
 void PowerSpectrumF::compute_power_spectrum(vector<s_Halo>& tracer_cat, string space_p,string property){

#ifdef _VERBOSE_POWER_
   this->So.enter(__PRETTY_FUNCTION__);
#endif

   time_t start;
   time (&start);
#ifdef _USE_OMP_
   int NTHREADS=_NTHREADS_;
   omp_set_num_threads(NTHREADS);
#endif

   string file_pow;
   if(space_p=="real")
     file_pow=this->file_power_real_space;
   else if (space_p=="redshift")
     file_pow=this->file_power_redshift_space;


   int N_intervals=1;
   if(property==_MASS_)
     N_intervals=this->params._NMASSbins_power();
   else if (property==_VMAX_)
     N_intervals=this->params._NVMAXbins_power();

   this->power_in_bins.resize(N_intervals);

   for(int im=0; im< N_intervals;++im)
     {
       fftw_functions.set_imcut(im);
       this->file_power=file_pow;
       if(property==_MASS_)
     this->file_power=file_pow+"_massbin"+to_string(im);
       else if (property==_VMAX_)
     this->file_power=file_pow+"_vmaxbin"+to_string(im);

       this->File.input_type=this->params._input_type();
       ULONG in_new=0;
       vector<s_Halo> final_cat; //* Define a s_Halo container
       if(property==_MASS_)
     {

       in_new=0;
       if(space_p=="redshift"){
         for(ULONG i=0;i<tracer_cat.size();++i)
           if(tracer_cat[i].mass>=pow(10,this->params._MASSbins_min(im)) && tracer_cat[i].mass<pow(10,this->params._MASSbins_max(im)))
         {
           final_cat.push_back(s_Halo());
           final_cat[in_new].mass=tracer_cat[i].mass;
           final_cat[in_new].coord1=tracer_cat[i].coord1;
           final_cat[in_new].coord2=tracer_cat[i].coord2;
           final_cat[in_new].coord3=tracer_cat[i].coord3;
           final_cat[in_new].vel1=tracer_cat[i].vel1;
           final_cat[in_new].vel2=tracer_cat[i].vel2;
           final_cat[in_new].vel3=tracer_cat[i].vel3;
           in_new++;
         }
       }
       else
         {
           for(ULONG i=0;i<tracer_cat.size();++i)
         if(tracer_cat[i].mass>=pow(10,this->params._MASSbins_min(im)) && tracer_cat[i].mass<pow(10,this->params._MASSbins_max(im)))
           {
             final_cat.push_back(s_Halo());
             final_cat[in_new].mass=tracer_cat[i].mass;
             final_cat[in_new].coord1=tracer_cat[i].coord1;
             final_cat[in_new].coord2=tracer_cat[i].coord2;
             final_cat[in_new].coord3=tracer_cat[i].coord3;
             in_new++;
           }
         }
     }
       else if (property==_VMAX_)
     {

       in_new=0;
       if(space_p=="redshift")
         {
           for(ULONG i=0;i<tracer_cat.size();++i)
         if(tracer_cat[i].vmax>=this->params._VMAXbins_min(im) && tracer_cat[i].vmax< this->params._VMAXbins_max(im))
           {
             final_cat.push_back(s_Halo());
             final_cat[in_new].vmax=tracer_cat[i].vmax;
             final_cat[in_new].coord1=tracer_cat[i].coord1;
             final_cat[in_new].coord2=tracer_cat[i].coord2;
             final_cat[in_new].coord3=tracer_cat[i].coord3;
             final_cat[in_new].vel1=tracer_cat[i].vel1;
             final_cat[in_new].vel2=tracer_cat[i].vel2;
             final_cat[in_new].vel3=tracer_cat[i].vel3;
             in_new++;
           }
         }
       else
         {
           for(ULONG i=0;i<tracer_cat.size();++i)
         if(tracer_cat[i].vmax>= this->params._VMAXbins_min(im) && tracer_cat[i].vmax< this->params._VMAXbins_max(im))
           {
             final_cat.push_back(s_Halo());
             final_cat[in_new].vmax=tracer_cat[i].vmax;
             final_cat[in_new].coord1=tracer_cat[i].coord1;
             final_cat[in_new].coord2=tracer_cat[i].coord2;
             final_cat[in_new].coord3=tracer_cat[i].coord3;
             in_new++;
           }
         }
     }
       else if (property=="_NONE_")
     {
       in_new=tracer_cat.size();
       final_cat.resize(tracer_cat.size());
       if(space_p=="redshift")
         {
           for(ULONG i=0;i<tracer_cat.size();++i)
         {
           final_cat[i].coord1=tracer_cat[i].coord1;
           final_cat[i].coord2=tracer_cat[i].coord2;
           final_cat[i].coord3=tracer_cat[i].coord3;
           final_cat[i].vel1=tracer_cat[i].vel1;
           final_cat[i].vel2=tracer_cat[i].vel2;
           final_cat[i].vel3=tracer_cat[i].vel3;
         }
         }
       else
         {
           for(ULONG i=0;i<tracer_cat.size();++i)
         {
           final_cat[i].coord1=tracer_cat[i].coord1;
           final_cat[i].coord2=tracer_cat[i].coord2;
           final_cat[i].coord3=tracer_cat[i].coord3;
         }
         }
     }

       So.message_screen("Number of tracers selected (in power func)= ",in_new);

#ifdef _FULL_VERBOSE_
       if (property==_VMAX_)
     {
       So.message_screen("Minimum value of vmax selected = ",this->params._VMAXbins_min(im));
       So.message_screen("Maximum value of vmax selected = ",this->params._VMAXbins_max(im));
     }
       else if(property==_MASS_)
     {
       So.message_screen("Minimum value of halo mass selected = ",pow(10,this->params._MASSbins_min(im)));
       So.message_screen("Maximum value of halo mass selected = ",pow(10,this->params._MASSbins_max(im)));
         }

#endif
       this->N_galaxy=in_new;
       real_prec mean_density=static_cast<real_prec>(in_new)/pow(this->params._Lbox(),3);
       s_data_structure s_data_struct_g;
       s_data_struct_g.properties=final_cat;
       s_data_struct_g.system_of_coordinates=this->params._sys_of_coord_g();
       s_data_struct_g.mean_density=mean_density;
       s_data_struct_g.catalog="data";
       final_cat.clear();final_cat.shrink_to_fit();

       fftw_functions.set_n_gal(in_new);
       fftw_functions.resize_fftw_vectors();
#ifdef _VERBOSE_POWER_
       fftw_functions.write_fftw_parameters();
       So.message_screen("Interpolating galaxy density field on a grid");
#endif

       if(space_p=="real")
         fftw_functions.get_interpolated_density_field_real_space(&s_data_struct_g,false,"any");
       else if (space_p=="redshift")
         fftw_functions.get_interpolated_density_field(&s_data_struct_g,false,"any");

       real_prec vol=pow(this->params._Lbox(),3);
       fftw_functions.raw_sampling(vol);
       fftw_functions.get_parameters_estimator(true);
       fftw_functions.get_fluctuation();

       // *****************************************************************************************
       // *****************************************************************************************
       kvector_data.clear();
       kvector_data.shrink_to_fit();
       kvector_window.clear();
       kvector_window.shrink_to_fit();
       if(this->params._type_of_binning()=="linear")
     {
       for(int i=0;i<this->params._d_Nnp_data();i++)
         kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
       for(int i=0;i<this->params._d_Nnp_window();i++)
         kvector_window.push_back(this->params._d_kmin()+this->params._d_DeltaK_window()*(i+0.5));
     }
       else  if(this->params._type_of_binning()=="log")
     {
       for(int i=0;i<kvector_data.size();i++)
         kvector_data.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
       for(int i=0;i<kvector_window.size();i++)
         kvector_window.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
     }
       for(int i=0;i<this->params._d_Nnp_data();i++)
     kvector_data2d.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
       for(int i=0;i<params._N_mu_bins();i++)
     muvector.push_back(-1.0+this->params._d_Deltamu()*(i+0.5));

       // *****************************************************************************
       // Resize arrays for P(k), and 2d P(k). Compute and write to file

       this->pk0.clear();
       this->pk0.shrink_to_fit();
       this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
       this->pk2.resize(this->params._d_Nnp_data(),0); //Quadrupole
       this->pk4.resize(this->params._d_Nnp_data(),0); //Hexadecapole
       this->pk_w.clear();
       this->pk_w.shrink_to_fit();
       this->pk_w.resize(this->params._d_Nnp_window(),0); //W(k)

       this->modes_g.clear();
       this->modes_g.shrink_to_fit();
       this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance



       this->pkk.resize(this->params._d_Nnp_data());
       this->pmk.resize(params._N_mu_bins());
#ifdef _WRITE_2DPOWER_
       for(int i=0;i<this->params._d_Nnp_data();i++)
     this->pkk[i].resize(this->params._d_Nnp_data(),0);
       for(int i=0;i<params._N_mu_bins();i++)
     this->pmk[i].resize(this->params._d_Nnp_data(),0);
#endif
       fftw_functions.get_power_spectrum_fkp(this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);

       this->power_in_bins[im].modes=this->modes_g;
       this->power_in_bins[im].kvector=this->kvector_data;
       this->power_in_bins[im].pk0=this->pk0;
       this->power_in_bins[im].pk2=this->pk2;
       this->power_in_bins[im].pk4=this->pk4;

       So.DONE();

#ifndef _WRITE_MULTIPOLES_
       this->write_power_and_modes();
#else
       this->write_power_spectrum(false); // argument asks to write sigma or not
#endif
     }// closes loop of bins or cuts

 }


// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

#define _use_two_quartiles_

 // This function computs lss bias, pearson, marked power and power of tracer in bins of differnet halo properties

 // The ordering of the properties is fixed, but the name of the ouput dir must emphasize which is the main property somehow.


 void PowerSpectrumF::compute_power_spectrum_halo_bias(string space_p)
 {

     time_t time_POWER;
     time(&time_POWER);

     bool get_marked=this->params._Get_marked_power_spectrum();

#ifdef _VERBOSE_POWER_
   this->So.enter(__PRETTY_FUNCTION__);
#endif

   time_t start;
   time (&start);
#ifdef _USE_OMP_
   int NTHREADS=_NTHREADS_;
   omp_set_num_threads(NTHREADS);
#endif

   // **************************************************************************************************
   // **************************************************************************************************
   // **************************************************************************************************
   Catalog tracer(params);
   tracer.read_catalog(params._Input_dir_cat()+params._file_catalogue(),0);
   this->set_params(tracer.params); // params has been updated inside the catalog class.

   tracer.Get_SO_tracer();

   // **************************************************************************************************
   // **************************************************************************************************
   // **************************************************************************************************
   this->fftw_functions.set_params(this->params);
   // **************************************************************************************************
   ULONG Nbins=this->params._Nbins_hist();  // Number of bins for 1d or 2d histograms
   // **************************************************************************************************
   string file_pow;   //Output file name
   if (space_p=="redshift_space")
     file_pow=this->file_power_redshift_space;
   else
     file_pow=this->file_power_real_space;

   string file_pow_marked;
   if (space_p=="redshift_space")
     file_pow_marked=this->file_power_marked_redshift_space;
   else
     file_pow_marked=this->file_power_marked_real_space;

   string file_pow_cross=this->file_power_cross;

   // **************************************************************************************************

   vector<string>prop_name;
   vector<int>prop_Nbins;
   vector<real_prec>variance_property;
   vector<real_prec>mean_prop;
   vector<bool>used_prop;
   vector<bool>secondary_prop;

   // *Get the total number of propertye bis* //
   // * The ordeing of alocation must coincide with teh ordering of the loops */


   // **************************************************************************************************
   // **************************************************************************************************
    // Counter on properties
   int Number_of_properties=0;
   // **************************************************************************************************
   // **************************************************************************************************

   // ---------------------------------------
   int label_mass=Number_of_properties;
#ifdef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
   if(this->params._i_mass_g()<0)
   {
     this->So.message_screen("Warning, Mass used as primary property but not specified in input par file. Check");
    exit(0);
   }
   int Nbins_mass=this->params._NMASSbins_power();
   prop_name.push_back("_MASS_");
   used_prop.push_back(true);
   prop_Nbins.push_back(Nbins_mass);
   secondary_prop.push_back(false);
   Number_of_properties++;
#else
   bool bmass=false;
   if(this->params._i_mass_g()>0){
     used_prop.push_back(true);
     bmass=true;
   }
   else
     used_prop.push_back(false);
   int Nbins_mass=this->params._NVMAXbins_power();
   prop_Nbins.push_back(Nbins_mass);
   prop_name.push_back("_MASS_");
   Number_of_properties++;
   secondary_prop.push_back(true);
#endif


   // ---------------------------------------
   int label_vmax=Number_of_properties;
#ifdef _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
   if(this->params._i_vmax_g()<0)
   {
     this->So.message_screen("Warning, Vmax used as primary property but not specified in input par file. Check");
    exit(0);
   }
   int Nbins_vmax=this->params._NVMAXbins_power();
   prop_name.push_back("_VMAX_");
   used_prop.push_back(true);
   prop_Nbins.push_back(Nbins_vmax);
   secondary_prop.push_back(false);
   Number_of_properties++;
#else
   bool bvmax=false;
   if(this->params._i_vmax_g()>0)
   {
     used_prop.push_back(true);
    bvmax=true;
   }
   else
     used_prop.push_back(false);
   int Nbins_vmax=this->params._NVMAXbins_power();
   prop_Nbins.push_back(Nbins_vmax);
   prop_name.push_back("_VMAX_");
   secondary_prop.push_back(true);

   Number_of_properties++;
#endif

   // ---------------------------------------
   int label_rs=Number_of_properties;
   if(this->params._i_rs_g()>0)
     used_prop.push_back(true);
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   int Nbins_rs=this->params._NRSbins_power();
   prop_Nbins.push_back(Nbins_rs);
   prop_name.push_back("_RS_");
   Number_of_properties++;
   // ---------------------------------------
   int label_rvir=Number_of_properties;
   if(this->params._i_rvir_g()>0)
     used_prop.push_back(true);
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   int Nbins_rvir=this->params._NRVIRbins_power();
   prop_Nbins.push_back(Nbins_rvir);
   prop_name.push_back("_RVIR_");
   Number_of_properties++;
   // ---------------------------------------
   int label_concentration=Number_of_properties;

#ifdef _USE_CONCENTRATION_
   if(this->params._i_rvir_g()<0 || this->params._i_rs_g()<0)
    {
       So.message_warning("Rvir or Rs not used. Concentration cannot be defined");
       used_prop.push_back(false);
    }
    else
       used_prop.push_back(true);
#endif
   secondary_prop.push_back(true);
   int Nbins_concentration=this->params._NCONCENTRATIONbins_power();
   prop_Nbins.push_back(Nbins_concentration);
   prop_name.push_back("_CONCENTRATION_");
   Number_of_properties++;
   // ---------------------------------------
   int label_spin=Number_of_properties;
   if(this->params._i_spin_g()>0)
     used_prop.push_back(true);
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   int Nbins_spin=this->params._NSPINbins_power();
   prop_Nbins.push_back(Nbins_spin);
   prop_name.push_back("_SPIN_");
   Number_of_properties++;
   // ---------------------------------------
   int label_spin_bullock=Number_of_properties;
   if(this->params._i_spin_bullock_g()>0)
     used_prop.push_back(true);
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   int Nbins_spin_bullock=this->params._NSPINBULLOCKbins_power();
   prop_Nbins.push_back(Nbins_spin_bullock);
   prop_name.push_back("_SPIN_BULLOCK_");
   Number_of_properties++;
   // ---------------------------------------
   int label_vrms=Number_of_properties;
   if(this->params._i_vrms_g()>0)
     used_prop.push_back(true);
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   int Nbins_vrms=this->params._NVRMSbins_power();
   prop_Nbins.push_back(Nbins_vrms);
   prop_name.push_back("_VRMS_");
   Number_of_properties++;
   // ---------------------------------------
   int label_virial=Number_of_properties;
   if(this->params._i_virial_g()>0)
     used_prop.push_back(true);
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   int Nbins_virial=this->params._NVIRIALbins_power();
   prop_Nbins.push_back(Nbins_virial);
   prop_name.push_back("_VIRIAL_");
   Number_of_properties++;
   // ---------------------------------------
   int label_btoa=Number_of_properties;
   if(this->params._i_b_to_a_g()>0)
     used_prop.push_back(true);
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   int Nbins_btoa=this->params._NBTOAbins_power();
   prop_Nbins.push_back(Nbins_btoa);
   prop_name.push_back("_BTOA_");
   Number_of_properties++;
   // ---------------------------------------
   int label_ctoa=Number_of_properties;
   if(this->params._i_c_to_a_g()>0)
     used_prop.push_back(true);
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   int Nbins_ctoa=this->params._NCTOAbins_power();
   prop_Nbins.push_back(Nbins_ctoa);
   prop_name.push_back("_CTOA_");
   Number_of_properties++;
   // ---------------------------------------
   int label_mach=Number_of_properties;
   int Nbins_mach=this->params._NMACHbins_power(); // ya viene seleccionad a 1 enc aso que no queramos mach
   prop_Nbins.push_back(Nbins_mach);
   bool mach=false;
   prop_name.push_back("_MACH_");
   secondary_prop.push_back(true);
   Number_of_properties++;
   if(this->params._Get_tracer_local_mach_number())
     {
       used_prop.push_back(true);
       mach=true;
     }
   else
   used_prop.push_back(false);
   // ---------------------------------------
   int label_bias=Number_of_properties;
   bool tbias=false;
   int Nbins_bias=this->params._NBIASbins_power();// ya viene seleccionado a 1 en caso que no queramos bias
   prop_Nbins.push_back(Nbins_bias);
   prop_name.push_back("_BIAS_");
   Number_of_properties++;
   if(this->params._Get_tracer_bias()){
     used_prop.push_back(true);
     tbias=true;
   }
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   // ---------------------------------------
   int label_lc=Number_of_properties;
   bool tlc=false;
   int Nbins_lc=this->params._NLCbins_power();// ya viene seleccionado a 1 en caso que no queramos bias
   prop_Nbins.push_back(Nbins_lc);
   prop_name.push_back("_LOCAL_OVERDENSITY_");
   Number_of_properties++;
   if(this->params._Get_local_overdensity()){
     tlc=true;
     used_prop.push_back(true);
   }
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   // ---------------------------------------
   int label_ta=Number_of_properties;
   prop_name.push_back("_TIDAL_ANISOTROPY_");
   Number_of_properties++;
   int Nbins_ta=this->params._NTAbins_power();// ya viene seleccionado a 1 en caso que no queramos bias
   prop_Nbins.push_back(Nbins_ta);
   bool bta=false;
   if(this->params._Get_tidal_anisotropy_at_halo()) {
     bta=true;
     used_prop.push_back(true);
   }
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   // ---------------------------------------
   int label_ph=Number_of_properties;
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
   int Nbins_ph=this->params._NPHbins_power();
   prop_name.push_back("_PEAK_HEIGHT_");
   used_prop.push_back(true);
   prop_Nbins.push_back(Nbins_ph);
   secondary_prop.push_back(false);
   Number_of_properties++;
#else
   prop_name.push_back("_PEAK_HEIGHT_");
   Number_of_properties++;
   bool bph=false;
   if(this->params._Get_peak_height_at_halo()>0){
     used_prop.push_back(true);
    bph=true;
   }
   else
     used_prop.push_back(false);
   secondary_prop.push_back(true);
   int Nbins_ph=this->params._NPHbins_power();
   prop_Nbins.push_back(Nbins_ph);
#endif

   // ---------------------------------------
   int label_da=Number_of_properties;
   prop_name.push_back("_DACH_");
   Number_of_properties++;
   int Nbins_dach=this->params._NDACHbins_power();// ya viene seleccionado a 1 en caso que no queramos bias
   prop_Nbins.push_back(Nbins_dach);
   bool dach=false;
   secondary_prop.push_back(true);
   if(true==this->params._Get_tracer_local_dach_number())
   {
     dach=true;
     used_prop.push_back(true);
   }
   else
     used_prop.push_back(false);
   // ---------------------------------------
   int label_dm_local=Number_of_properties;
   prop_name.push_back("_LOCALDM_");
   Number_of_properties++;
   int Nbins_dm_local=this->params._NLOCALDMbins_power();// ya viene seleccionado a 1 en caso que no queramos bias
   prop_Nbins.push_back(Nbins_dm_local);
   bool dm_local=false;
   secondary_prop.push_back(true);
   if(true==this->params._Get_tracer_local_dm_density())
   {
     dm_local=true;
     used_prop.push_back(true);
   }
   else
     used_prop.push_back(false);

   // ---------------------------------------
   // ---------------------------------------
    So.message_screen("Total number of properties:", Number_of_properties);


   // **************************************************************************************************
   // **************************************************************************************************
   // **************************************************************************************************
   int Ncwt=0;
   vector<real_prec> DM_DEN_FIELD( this->params._NGRID(),0);
   this->File.read_array(this->params._Input_Directory_X()+this->params._Name_Catalog_X(),DM_DEN_FIELD);
   for(ULONG i=0;i<DM_DEN_FIELD.size();++i)
    if(DM_DEN_FIELD[i]<0)
        DM_DEN_FIELD[i]=0;
    So.message_screen("\tMin DM field:",get_min_nm(DM_DEN_FIELD));
    So.message_screen("\tMax DM field:",get_max_nm(DM_DEN_FIELD));
    So.message_screen("\tMean DM field:",get_mean(DM_DEN_FIELD));
#ifdef _USE_CWC_HALO_ANALYSIS_
   vector<real_prec>DM_OVERDENSITY_FIELD(DM_DEN_FIELD.size(),0 );
   get_overdens(DM_DEN_FIELD,DM_OVERDENSITY_FIELD);
#endif


    // **************************************************************************************************
   // Get DM power spectrum
   this->pk0.clear();
   this->pk0.shrink_to_fit();
   this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
   this->params.set_input_type("density_grid");
   string original_name=this->params._Name_survey();
   this->params.set_Name_survey("UNITSIM_DM");
   this->params.set_mass_assignment_scheme("CIC");
   this->params.set_SN_correction(false);
   this->set_output_filenames();
   this->compute_power_spectrum_grid(DM_DEN_FIELD, true);
   vector<real_prec>power_dm(this->params._d_Nnp_data(),0);
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
   for(ULONG i=0;i<power_dm.size();++i)
     power_dm[i]=this->pk0[i];      // The container pk0 will be cleared and reused. power_dm iwll be used to get bias object by object
   // -------------------------------------------------------------------------------------------------------
   if(true==this->params._Get_tracer_bias())
     {
       // ESTE TIPO DE OPERACIONES USUALMENTE ESTAN HECHAS cuando se lee el catalog (con los méttodos de Catalog::)
       // Tengo conflicto para hacerlas alli ya que Power no esta subordinado a Catalog
       this->So.message_screen("Getting object-to-object bias");
       this->object_by_object_bias(tracer.Halo,DM_DEN_FIELD);
       this->So.message_screen("\tMin Bias  =", tracer.get_min("_BIAS_"));
       this->So.message_screen("\tMax Bias  =", tracer.get_max("_BIAS_"));
       this->So.DONE();
       cout<<""<<endl;
     }

   exit(0);
   // **************************************************************************************************
   // **************************************************************************************************
   // **************************************************************************************************


#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
   // If this preproc is disableD, we can still want to use peak height as secondary property so we follow whatever the parameter file said
   tracer.get_peak_height_at_tracer();
#else
   if(true==this->params._Get_peak_height_at_halo())
     {
       tracer.get_peak_height_at_tracer();
       this->So.message_screen("   Min Peak Height  =", tracer.get_min("_PEAK_HEIGHT_"));
       this->So.message_screen("   Max Peak Height =", tracer.get_max("_PEAK_HEIGHT_"));
       cout<<""<<endl;
     }
#endif

   // **************************************************************************************************
   // Get CW classification

#ifdef _USE_CWC_HALO_ANALYSIS_
   // We can here read the dark matter density field and determine the CWC
   this->cwclass.set_params(this->params);
   this->cwclass.get_CWC(DM_OVERDENSITY_FIELD);
   string file_cwc = this->params._Output_directory()+"CWC_vf_lambdath"+to_string(this->params._lambdath())+"_p"+to_string(this->params._unitsim_plabel())+"_Nft"+to_string(this->params._Nft())+".txt";
   ofstream cwcf; cwcf.open(file_cwc.c_str());
   cwcf<<this->params._lambdath()<<"\t"<<this->cwclass._knots_fraction()<<"\t"<<this->cwclass._filaments_fraction()<<"\t"<<this->cwclass._sheets_fraction()<<"\t"<<this->cwclass._voids_fraction()<<endl;
   cwcf.close();

    cout<<endl;
   this->So.message_screen("Assigning CWT to tracers=");
#pragma omp parallel for
   for(ULONG i=0;i<tracer._NOBJS();++i)
      tracer.Halo[i].gal_cwt=this->cwclass.CWClass[tracer.Halo[i].GridID]; //esto asigna 1, 2, 3, 4

   So.DONE();

   Ncwt=this->cwclass.cwt_used.size();
   So.message_screen("Number cosmic-web types requested: ",Ncwt);
   if(true==this->params._Get_tidal_anisotropy_at_halo())
     {
       vector<real_prec>tidal(this->params._NGRID(),0);
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
       for(ULONG i=0;i<this->params._NGRID() ;++i)
         tidal[i]=tidal_anisotropy(this->cwclass.lambda1[i], this->cwclass.lambda2[i], this->cwclass.lambda3[i]);
       tracer.get_tracer_tidal_anisotropy(tidal);

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
   for(ULONG i=0;i<tracer._NOBJS() ;++i) //loop over the "observed obejcts", i.e, with cuts already set
    {
       tracer.Halo[i].lambda1 =this->cwclass.lambda1[tracer.Halo[i].GridID];
       tracer.Halo[i].lambda2 =this->cwclass.lambda2[tracer.Halo[i].GridID];
       tracer.Halo[i].lambda3 =this->cwclass.lambda3[tracer.Halo[i].GridID];
    }
     this->So.message_screen("    Min tidal_anisotropy  =", tracer.get_min("_TIDAL_ANISOTROPY_"));
     this->So.message_screen("    Max tidal_anisotropy  =", tracer.get_max("_TIDAL_ANISOTROPY_"));
     cout<<""<<endl;
     tidal.clear();tidal.shrink_to_fit();
     }
#endif

    // **************************************************************************************************
    if(true==this->params._Get_tracer_local_dm_density())
    {
    this->So.message_screen("Assigning log(delta_dm+1) from cells to halos");
 #pragma omp parallel for
    for(ULONG i=0;i<tracer._NOBJS();++i)
       tracer.Halo[i].local_dm=log10(1+DM_OVERDENSITY_FIELD[tracer.Halo[i].GridID]);

    this->So.message_screen("    Min localdm  =", tracer.get_min("_LOCALDM_"));
    this->So.message_screen("    Max localdm  =", tracer.get_max("_LOCALDM_"));

    }

#ifdef _USE_CWC_HALO_ANALYSIS_
    DM_OVERDENSITY_FIELD.clear();
    DM_OVERDENSITY_FIELD.shrink_to_fit();
#endif



   this->params.set_Name_survey(original_name);
   this->params.set_SN_correction(true);
   this->params.set_mass_assignment_scheme("TSC");
   this->set_output_filenames();
   // **************************************************************************************************
   // **************************************************************************************************
   // **************************************************************************************************
   // Define number of bins in each property
   int Nmass_ind=Nbins_mass;
   int Nvmax_ind=Nbins_vmax;
   int Nrs_ind=Nbins_rs;
   int Nrvir_ind=Nbins_rvir;
   int Nrconcentration_ind=Nbins_concentration;
   int Nspin_ind=Nbins_spin;
   int Nspinbullock_ind=Nbins_spin_bullock;
   int Nvrms_ind=Nbins_vrms;
   int Nvirial_ind=Nbins_virial;
   int Nbtoa_ind=Nbins_btoa;
   int Nctoa_ind=Nbins_ctoa;
   int Nmach_ind=Nbins_mach;
   int Nbias_ind=Nbins_bias;
   int Nlc_ind=Nbins_lc;
   int Nta_ind=Nbins_ta;
   int Nph_ind=Nbins_ph;
   int Ndach_ind=Nbins_dach;
   int Ndmlocal_ind=Nbins_dm_local;
   // **************************************************************************************************
   // **************************************************************************************************
   // **************************************************************************************************
   int Nprimary_bins=0;
#ifdef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
    Nprimary_bins=Nbins_mass;
#endif

#ifdef _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
    Nprimary_bins=Nbins_vmax;
#endif
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
    Nprimary_bins=Nbins_ph;
#endif
    // **************************************************************************************************
    // **************************************************************************************************
    // **************************************************************************************************
    // **************************************************************************************************
    // **************************************************************************************************
    // **************************************************************************************************

    // WE can write a random sub-sample of the total catalogs to be read in python and do 2d historgrams.
//    string rcatalog=this->params._Output_directory()+"catalog_reduced.txt";
//    tracer.select_random_subsample(0.2, rcatalog); // DONE IN PCA NOW

    // **************************************************************************************************


    // get randomized versions
    Catalog tracer_randomize(params);
    tracer_randomize.define_property_bins(this->params._NPROPbins_bam(), "_MASS_");
    string rcatalog;
    tracer_randomize.set_NOBJS(tracer._NOBJS());


    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_cwt.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);

    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_", "_MACH_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_", "_MACH_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_", "_MACH_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_twopr_mach_cwt.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);


    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_", "_DACH_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_", "_DACH_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_", "_DACH_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_twopr_dach_cwt.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);


    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_", "_VIRIAL_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_", "_VIRIAL_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_", "_VIRIAL_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_twopr_virial.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);

    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_", "_CTOA_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_", "_CTOA_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_", "_CTOA_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_twopr_ctoa.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);


    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_", "_LOCALDM_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_", "_LOCALDM_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_", "_LOCALDM_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_twopr_localdm_cwt.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);


    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_", "_TIDAL_ANISOTROPY_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_","_TIDAL_ANISOTROPY_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_", "_TIDAL_ANISOTROPY_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_twopr_ta_cwt.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);

    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_", "_LOCAL_OVERDENSITY_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_","_LOCAL_OVERDENSITY_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_", "_LOCAL_OVERDENSITY_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_twopr_lc_cwt.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);


    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_", "_LOCAL_OVERDENSITY_", "_MACH_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_","_LOCAL_OVERDENSITY_", "_MACH_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_", "_LOCAL_OVERDENSITY_", "_MACH_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_threepr_lc_mach_cwt.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);


    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_", "_LOCAL_OVERDENSITY_", "_LOCALDM_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_","_LOCAL_OVERDENSITY_", "_LOCALDM_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_", "_LOCAL_OVERDENSITY_", "_LOCALDM_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_threepr_lc_dm_cwt.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);

    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_", "_LOCAL_OVERDENSITY_", "_CTOA_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_","_LOCAL_OVERDENSITY_", "_CTOA_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_", "_LOCAL_OVERDENSITY_", "_CTOA_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_threepr_lc_ctoa_cwt.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);


    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_VMAX_", "_LOCAL_OVERDENSITY_", "_VIRIAL_");
    tracer_randomize.get_scaling_relation_primary_property("_CONCENTRATION_","_LOCAL_OVERDENSITY_", "_VIRIAL_");
    tracer_randomize.get_scaling_relation_primary_property("_SPIN_BULLOCK_", "_LOCAL_OVERDENSITY_", "_VIRIAL_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_threepr_lc_virial_cwt.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);


    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_BIAS_", "_LOCAL_OVERDENSITY_", "_LOCALDM_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_threepr_lc_dm_cwt_newbias.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);

    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_BIAS_", "_LOCAL_OVERDENSITY_", "_MACH_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_threepr_lc_mach_cwt_newbias.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);


    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_BIAS_", "_LOCAL_OVERDENSITY_", "_TIDAL_ANISOTROPY_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_threepr_lc_ta_cwt_newbias.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);

    tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_primary_property("_BIAS_", "_LOCALDM_", "_MACH_");
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_threepr_dm_mach_cwt_newbias.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);



/*

tracer_randomize.Halo.clear();
    tracer_randomize.Halo.shrink_to_fit() ;
    tracer_randomize.Halo.resize(tracer._NOBJS());
    tracer_randomize.Halo=tracer.Halo;
    tracer_randomize.get_scaling_relation_bias();
    rcatalog=this->params._Output_directory()+"catalog_reduced_randomized_newbias_newprops.txt";
    tracer_randomize.select_random_subsample(0.3,rcatalog);
*/



    exit(0);


    // **************************************************************************************************
    // **************************************************************************************************
    // PRINCIPAL COMPONENT ANALYSIS. Reduced catalogs are written in the PCA method


    if(this->params._Get_PCA())
    {
        So.message_screen("Doing PCA");
         tracer.PCA(prop_name, used_prop, "", true);
         So.DONE();
         exit(0);
    }
    // **************************************************************************************************
    // **************************************************************************************************
    // SECTION TO DO 2D HISTOGRAMS-CORRELATION RELATIONS BETWEEN HALOS
/*      {
        vector<real_prec>Vaux(Nbins*Nbins,0);
        get_2d_histogram(this->params._ldelta_X_min(),this->params._ldelta_X_max(),this->params._ldelta_Y_min(),this->params._ldelta_Y_max(),Nbins, DM_DEN_FIELD, aux_field,Vaux,true);
        this->File.write_array(file_hist,Vaux);
        this->mcmc.get_contour_levels(file_contours+"_contour_levels",Nbins, Vaux);
        Vaux.clear();Vaux.shrink_to_fit();
      }*/

    // **************************************************************************************************
    // **************************************************************************************************

#ifdef _USE_CWC_HALO_ANALYSIS_
   for(int icw=0;icw<=Ncwt;icw++)  // loop over nuber of cosmic-web types. ALL=0 knots. 1 = filaments: 2=sheets; 3 =voids
     {
       int ict=icw;// Ojo, esto asume que Halo[].gal_cwt es 1, 2, 3, 4 para k, f, s, v respectivamente
       So.message_screen("CWT ",icw);
#endif

       // ************************************LOOP OVER THE BINS OF THE PRIMARY PROPERTY**********************************************+
       for(int im_primary=0; im_primary< Nprimary_bins;++im_primary)
     {


        vector<real_prec> primary_field(this->params._NGRID(), 0);

#ifdef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
       So.message_screen("Mass bin ",im_primary);
#elif defined _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
       So.message_screen("Vmax bin ",im_primary);
#elif defined _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
       So.message_screen("Nu-bin ",im_primary);
#endif

       Catalog tracer_aux(this->params);
       // if the bins are to be defined with same number of objects, here is the place to redefine those bins for each mass bin
       // using inside this loop the  members f the params class setbins*()
       // *Selecting the trabcers and its propertis in each mass bin*//
       ULONG counter_m=0;

       So.message_screen("Selecting tracers in bin of primary property");

#ifdef _USE_CWC_HALO_ANALYSIS_
       if(icw==0)// THis selects all objects regardless their CW clasiffication.
         {
#endif

           for(ULONG i=0;i<tracer._NOBJS();++i)
         {
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
         if(tracer.Halo[i].peak_height>= this->params._PHbins_min(im_primary) && tracer.Halo[i].peak_height< this->params._PHbins_max(im_primary))
#elif defined  _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
           if(tracer.Halo[i].mass>= pow(10,this->params._MASSbins_min(im_primary)) && tracer.Halo[i].mass< pow(10,this->params._MASSbins_max(im_primary)))
#elif defined  _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
             if(tracer.Halo[i].vmax>= pow(10,this->params._VMAXbins_min(im_primary)) && tracer.Halo[i].vmax< pow(10,this->params._VMAXbins_max(im_primary)))
#endif
               {
             tracer_aux.Halo.push_back(s_Halo());
             tracer_aux.Halo[counter_m].GridID = tracer.Halo[i].GridID;
             tracer_aux.Halo[counter_m].coord1 = tracer.Halo[i].coord1;
             tracer_aux.Halo[counter_m].coord2 = tracer.Halo[i].coord2;
             tracer_aux.Halo[counter_m].coord3 = tracer.Halo[i].coord3;
             tracer_aux.Halo[counter_m].vel1 = tracer.Halo[i].vel1;
             tracer_aux.Halo[counter_m].vel2 = tracer.Halo[i].vel2;
             tracer_aux.Halo[counter_m].vel3 = tracer.Halo[i].vel3;
             tracer_aux.Halo[counter_m].mass = tracer.Halo[i].mass;
             tracer_aux.Halo[counter_m].vmax = tracer.Halo[i].vmax;
             tracer_aux.Halo[counter_m].rs = tracer.Halo[i].rs;
             tracer_aux.Halo[counter_m].rvir = tracer.Halo[i].rvir;
             tracer_aux.Halo[counter_m].concentration = tracer.Halo[i].concentration;
             tracer_aux.Halo[counter_m].spin = tracer.Halo[i].spin;
             tracer_aux.Halo[counter_m].spin_bullock = tracer.Halo[i].spin_bullock;
             tracer_aux.Halo[counter_m].vrms = tracer.Halo[i].vrms;
             tracer_aux.Halo[counter_m].virial = tracer.Halo[i].virial;
             tracer_aux.Halo[counter_m].b_to_a = tracer.Halo[i].b_to_a;
             tracer_aux.Halo[counter_m].c_to_a = tracer.Halo[i].c_to_a;
             tracer_aux.Halo[counter_m].mach_number = tracer.Halo[i].mach_number;
             tracer_aux.Halo[counter_m].local_overdensity = tracer.Halo[i].local_overdensity;
             tracer_aux.Halo[counter_m].bias = tracer.Halo[i].bias;
             tracer_aux.Halo[counter_m].tidal_anisotropy = tracer.Halo[i].tidal_anisotropy;
             tracer_aux.Halo[counter_m].peak_height = tracer.Halo[i].peak_height;
             tracer_aux.Halo[counter_m].dach_number= tracer.Halo[i].dach_number;
             tracer_aux.Halo[counter_m].local_dm= tracer.Halo[i].local_dm;
             counter_m++;
               }//closes if
         } // closes loop
         }//closes if cwc
#ifdef _USE_CWC_HALO_ANALYSIS_
       else if(icw>0)
         {
           for(ULONG i=0;i<tracer._NOBJS();++i)
         {
           if(tracer.Halo[i].gal_cwt==ict)
             {
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
               if(tracer.Halo[i].peak_height>= this->params._PHbins_min(im_primary) && tracer.Halo[i].peak_height< this->params._PHbins_max(im_primary))
#elif defined  _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
             if(tracer.Halo[i].mass>= pow(10,this->params._MASSbins_min(im_primary)) && tracer.Halo[i].mass< pow(10,this->params._MASSbins_max(im_primary)))
#elif defined  _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
               if(tracer.Halo[i].vmax>= pow(10,this->params._VMAXbins_min(im_primary)) && tracer.Halo[i].vmax< pow(10,this->params._VMAXbins_max(im_primary)))
#endif
                 {
                   tracer_aux.Halo.push_back(s_Halo());
                   tracer_aux.Halo[counter_m].GridID = tracer.Halo[i].GridID;
                   tracer_aux.Halo[counter_m].coord1 = tracer.Halo[i].coord1;
                   tracer_aux.Halo[counter_m].coord2 = tracer.Halo[i].coord2;
                   tracer_aux.Halo[counter_m].coord3 = tracer.Halo[i].coord3;
                   tracer_aux.Halo[counter_m].vel1 = tracer.Halo[i].vel1;
                   tracer_aux.Halo[counter_m].vel2 = tracer.Halo[i].vel2;
                   tracer_aux.Halo[counter_m].vel3 = tracer.Halo[i].vel3;
                   tracer_aux.Halo[counter_m].mass = tracer.Halo[i].mass;
                   tracer_aux.Halo[counter_m].vmax = tracer.Halo[i].vmax;
                   tracer_aux.Halo[counter_m].rs = tracer.Halo[i].rs;
                   tracer_aux.Halo[counter_m].rvir = tracer.Halo[i].rvir;
                   tracer_aux.Halo[counter_m].concentration = tracer.Halo[i].concentration;
                   tracer_aux.Halo[counter_m].spin = tracer.Halo[i].spin;
                   tracer_aux.Halo[counter_m].spin_bullock = tracer.Halo[i].spin_bullock;
                   tracer_aux.Halo[counter_m].vrms = tracer.Halo[i].vrms;
                   tracer_aux.Halo[counter_m].virial = tracer.Halo[i].virial;
                   tracer_aux.Halo[counter_m].b_to_a = tracer.Halo[i].b_to_a;
                   tracer_aux.Halo[counter_m].c_to_a = tracer.Halo[i].c_to_a;
                   tracer_aux.Halo[counter_m].mach_number = tracer.Halo[i].mach_number;
                   tracer_aux.Halo[counter_m].local_overdensity = tracer.Halo[i].local_overdensity;
                   tracer_aux.Halo[counter_m].bias = tracer.Halo[i].bias;
                   tracer_aux.Halo[counter_m].tidal_anisotropy = tracer.Halo[i].tidal_anisotropy;
                   tracer_aux.Halo[counter_m].peak_height = tracer.Halo[i].peak_height;
                   tracer_aux.Halo[counter_m].dach_number= tracer.Halo[i].dach_number;
                   tracer_aux.Halo[counter_m].local_dm= tracer.Halo[i].local_dm;
                   counter_m++;
                 } // closes if
             } // closes if
         } // closes loop
         }// closes else if
#endif

       So.DONE();

       if(counter_m==0)
         So.message_warning("No tracers found in the interval", im_primary);
       else
         So.message_screen("Found ",counter_m);

#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
       tracer.set_Number_of_tracers_in_ph_bins(im_primary,counter_m);
#elif defined  _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
       tracer.set_Number_of_tracers_in_mass_bins(im_primary,counter_m);
#elif defined  _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
       tracer.set_Number_of_tracers_in_vmax_bins(im_primary,counter_m);
#endif


       tracer_aux.set_NOBJS(counter_m);

       // ************************************************************************************************************
       // ************************************************************************************************************
       // ************************************************************************************************************
       // ************************************************************************************************************

       // Here we masure marked power before starting the bins ins ec properties
       cout<<endl;
       if(true==this->params._Get_marked_power_spectrum() && counter_m>0)
     {
           So.message_screen("Measuring marked power spectrum:");

       s_data_structure s_data_struct_g_marked;
       this->N_galaxy=tracer_aux.Halo.size();
       real_prec mean_density=static_cast<real_prec>(tracer_aux.Halo.size())/pow(this->params._Lbox(),3);
       s_data_struct_g_marked.properties=tracer_aux.Halo;
       s_data_struct_g_marked.system_of_coordinates=this->params._sys_of_coord_g();
       s_data_struct_g_marked.mean_density=mean_density;
       s_data_struct_g_marked.catalog="data";
       fftw_functions.set_n_gal(tracer_aux.Halo.size());

           int first_sec_property_used=0;// this variable us used to computu/allocate/free memmory
#ifdef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
       first_sec_property_used=1;//the first secondary property used the vmax, labled 1
#elif defined _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
       first_sec_property_used=0;//the first secondary property used the mass, labled 0
#elif defined _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
           first_sec_property_used=0;//the first secondary property used the mass, labled 0
#endif


        for(int Nbb=0;Nbb<Number_of_properties;++Nbb) // Loop over the  properties to be used as marks, in bins of the primary poroperty
         {


         if(true==used_prop[Nbb] && true==secondary_prop[Nbb])//THis If is importante. Continues only if these properteis are asked to be used and are secondary
         {
           pair<real_prec,real_prec>stats=tracer_aux.get_variance(prop_name[Nbb],false);// false means that it gives <prop²> istead of <(prop-mean)²>
           real_prec mean_prop=stats.first;
           real_prec variance_property=stats.second;

           So.message_screen("Property ", prop_name[Nbb]);
           So.message_screen("Mean     ", mean_prop);
           So.message_screen("Variance ", variance_property);
           fftw_functions.set_mean_property_value(mean_prop);// Useful to divide by the mean each prop, to get prop/<mean> and then do the interpolation
#ifdef _USE_CWC_HALO_ANALYSIS_
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
           string file_lss_bias_marked=this->params._Output_directory()+"lss_bias_marked_nubin"+to_string(im_primary)+"_cwc"+to_string(icw)+prop_name[Nbb];
#elif defined  _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
           string file_lss_bias_marked=this->params._Output_directory()+"lss_bias_marked_massbin"+to_string(im_primary)+"_cwc"+to_string(icw)+prop_name[Nbb];
#elif defined  _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
           string file_lss_bias_marked=this->params._Output_directory()+"lss_bias_marked_vmaxbin"+to_string(im_primary)+"_cwc"+to_string(icw)+prop_name[Nbb];
#endif

#else
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
           string file_lss_bias_marked=this->params._Output_directory()+"lss_bias_marked_nubin"+to_string(im_primary)+"_"+prop_name[Nbb];
#elif defined  _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
           string file_lss_bias_marked=this->params._Output_directory()+"lss_bias_marked_massbin"+to_string(im_primary)+"_"+prop_name[Nbb];
#elif defined  _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
           string file_lss_bias_marked=this->params._/home/balaguera/data/Numerics/UNITSIM/REFERENCE/001/HALOS/SNAPSHOT_p65/NEW/BINNING_massbin2_cwt0_p65.txtOutput_directory()+"lss_bias_marked_vmaxbin"+to_string(im_primary)+"_"+prop_name[Nbb];
#endif
#endif

           ofstream blsm; blsm.open(file_lss_bias_marked.c_str());

           this->File.input_type=this->params._input_type();

           if(Nbb==first_sec_property_used)// Compute the raw number counts, only needed once, so we do it for Nbb=first index used
             {
               fftw_functions.field_external.clear();
               fftw_functions.field_external_s.clear();


               if(false==this->params._use_real_and_redshift_space())
             {
               if (space_p=="redshift_space")
                 {
                   So.message_screen("Interpolating galaxy density field on a grid");
                   fftw_functions.get_interpolated_density_field(&s_data_struct_g_marked, false, "any"); // this gives  fftw_functions.field_external
                 }
               else if (space_p=="real_space")
                 {
                   So.message_screen("Interpolating galaxy density field on a grid");
                   fftw_functions.get_interpolated_density_field_real_space(&s_data_struct_g_marked,false,"any"); // this gives  fftw_functions.field_external
                 }
             }
               else if(true==this->params._use_real_and_redshift_space())
                 this->fftw_functions.get_interpolated_density_field_real_and_redshift_space(&s_data_struct_g_marked,false, "any");
           }

           if(false==this->params._use_real_and_redshift_space())
            {
               if (space_p=="redshift_space")
             {
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
               file_pow_marked=this->file_power_marked_redshift_space+"_nubin"+to_string(im_primary)+"_cwt"+to_string(icw)+prop_name[Nbb];
#elif defined  _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
               file_pow_marked=this->file_power_marked_redshift_space+"_massbin"+to_string(im_primary)+"_cwt"+to_string(icw)+prop_name[Nbb];
#elif defined  _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
               file_pow_marked=this->file_power_marked_redshift_space+"_vmaxbin"+to_string(im_primary)+"_cwt"+to_string(icw)+prop_name[Nbb];
#endif
               So.message_screen("Interpolating weighted galaxy density field on a grid for", prop_name[Nbb]);
               fftw_functions.field_external_marked.clear();
               fftw_functions.get_interpolated_density_field(&s_data_struct_g_marked, true, prop_name[Nbb]);// this gives  fftw_functions.field_external_marked
             }//closes if
            else if(space_p=="real_space")
             {
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
               file_pow_marked=this->file_power_marked+"_nubin"+to_string(im_primary)+"_cwt"+to_string(icw)+prop_name[Nbb];
#elif defined  _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
               file_pow_marked=this->file_power_marked+"_massbin"+to_string(im_primary)+"_cwt"+to_string(icw)+prop_name[Nbb];
#elif defined  _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
               file_pow_marked=this->file_power_marked+"_vmaxbin"+to_string(im_primary)+"_cwt"+to_string(icw)+prop_name[Nbb];
#endif
               So.message_screen("Interpolating weighted galaxy density field on a grid for", prop_name[Nbb]);
               fftw_functions.field_external_marked.clear();
               fftw_functions.get_interpolated_density_field_real_space(&s_data_struct_g_marked,true, prop_name[Nbb]); // this gives  fftw_functions.field_external_marked
             }
           }
           else if(true==this->params._use_real_and_redshift_space())
             {
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
               file_pow_marked=this->file_power_marked+"_nubin"+to_string(im_primary)+"_cwt"+to_string(icw)+prop_name[Nbb];
#elif defined  _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
               file_pow_marked=this->file_power_marked+"_massbin"+to_string(im_primary)+"_cwt"+to_string(icw)+prop_name[Nbb];
#elif defined  _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
               file_pow_marked=this->file_power_marked+"_vmaxbin"+to_string(im_primary)+"_cwt"+to_string(icw)+prop_name[Nbb];
#endif
               So.message_screen("Interpolating weighted galaxy density field on a grid for", prop_name[Nbb]);
               fftw_functions.field_external_marked.clear();
               fftw_functions.field_external_marked_s.clear();
               fftw_functions.get_interpolated_density_field_real_and_redshift_space(&s_data_struct_g_marked,true, prop_name[Nbb]); // this gives  fftw_functions.field_external_marked

               // Write the weighted fields to binary:
               if(im_primary==0 && icw==0)
               {
                string outf=this->params._Output_directory()+"property_field"+prop_name[Nbb];
                this->File.write_array(outf,fftw_functions.field_external_marked);
               }


               So.DONE();
           }
            // NOTE:
           // We avoid get_overdens as (delta_w - delta) = n_w/barn - n/ barn. Below we assign to data_g the fluctuation(n_w/barn - n/ barn)
           // get_overdens(fftw_functions.field_external_marked,w_delta);
           //  get_overdens(fftw_functions.field_external,delta);
           fftw_functions.resize_fftw_vectors();
           fftw_functions.raw_sampling(pow(this->params._Lbox(),3));
           fftw_functions.get_parameters_estimator(true);
           real_prec nmean=static_cast<real_prec>(tracer_aux.Halo.size())/static_cast<real_prec>(this->params._NGRID()); // mean number of tracers in cells

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
           for(ULONG i=0;i<this->params._NGRID();++i) // Build the property-fluctuation as n_w/barn - n/ barn
                     fftw_functions.set_data_g(i, (static_cast<real_prec>(fftw_functions.field_external_marked[i])-static_cast<real_prec>(fftw_functions.field_external[i]))/static_cast<real_prec>(nmean));

           if (true==this->params._use_real_and_redshift_space())
             {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
               for(ULONG i=0;i<this->params._NGRID();++i) // Build the property-fluctuation as n_w/barn - n/ barn
             fftw_functions.set_data_g_rss(i, (static_cast<real_prec>(fftw_functions.field_external_marked_s[i])-static_cast<real_prec>(fftw_functions.field_external_s[i]))/static_cast<real_prec>(nmean));
             }

           fftw_functions.field_external_marked.clear(); fftw_functions.field_external_marked.shrink_to_fit();
           if(Nbb==Number_of_properties)
             fftw_functions.field_external.clear();fftw_functions.field_external.shrink_to_fit();
           if (true==this->params._use_real_and_redshift_space())
               if(Nbb==Number_of_properties)
                 fftw_functions.field_external_s.clear();fftw_functions.field_external_s.shrink_to_fit();



           real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
           fftw_functions.set_normal_power(pow(factor,-2));
           fftw_functions.set_shot_noise((variance_property -1.0)/static_cast<real_prec>(nmean));
           kvector_data.clear();
           kvector_data.shrink_to_fit();
           for(ULONG i=0;i<this->params._d_Nnp_data();i++)
             kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));


           if (true==this->params._use_real_and_redshift_space())
             {
               this->pk.clear();
               this->pk.shrink_to_fit();
               this->pk.resize(this->params._d_Nnp_data(),0); // Real space
             }
           this->pk0.clear();
           this->pk0.shrink_to_fit();
           this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
           this->pk2.resize(this->params._d_Nnp_data(),0); //Quadrupole
           this->pk4.resize(this->params._d_Nnp_data(),0); //Hexadecapole
           this->modes_g.clear();
           this->modes_g.shrink_to_fit();
           this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance
           this->pk_w.clear();
           this->pk_w.shrink_to_fit();
           this->pk_w.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance

           if (false==this->params._use_real_and_redshift_space())
             {
               fftw_functions.get_power_spectrum_fkp(this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);
               this->write_power_spectrum(false); // argument asks to write sigma or not
             }
           else
             {
               fftw_functions.get_power_spectrum_fkp(this->pk,this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);
               this->File.write_to_file(file_pow_marked,this->kvector_data,this->pk, this->pk0,this->pk2,this->pk4,this->modes_g);
             }

           fftw_functions.free_fftw_vectors();

           real_prec lss_bias=0;
           ULONG kcount=0;
           int ik=1;//to avoid zeros
           while(this->kvector_data[ik]<this->params._kmax_tracer_bias())
             {
               lss_bias+=sqrt(this->pk0[ik]/power_dm[ik]);
               ++ik;
               kcount++;
             }
           lss_bias/=kcount;
           So.message_screen("Large scale marked bias =", lss_bias);
           ik=1;//to avoid zeros
           real_prec var_lss_bias=0;
           while(this->kvector_data[ik]<this->params._kmax_tracer_bias())
             {
               var_lss_bias+=pow(this->pk0[ik]/power_dm[ik]-lss_bias*lss_bias,2);
               ++ik;
               kcount++;
             }
           var_lss_bias=sqrt(var_lss_bias/kcount);
           blsm<<lss_bias<<"\t"<<var_lss_bias<<endl;
           So.DONE();
           blsm.close();
         }//closes if  if(true==used_prop[Nbb] && true==secondary_prop[Nbb])
         } //closes loop over properties


       }// closes if(true==get_marked)



       // ************************************************************************************************************
       // END OF MARKED POWER SECTION
       //if marked is false, we still would like to have the primary field to have cross power computed below:
       else{
           if(true==this->params._Get_cross_power_spectrum())
           {
           s_data_structure s_data_struct_g_marked;
           this->N_galaxy=tracer_aux.Halo.size();
           real_prec mean_density=static_cast<real_prec>(tracer_aux.Halo.size())/pow(this->params._Lbox(),3);
           s_data_struct_g_marked.properties=tracer_aux.Halo;
           s_data_struct_g_marked.system_of_coordinates=this->params._sys_of_coord_g();
           s_data_struct_g_marked.mean_density=mean_density;
           s_data_struct_g_marked.catalog="data";
           fftw_functions.resize_fftw_vectors();
           if(false==this->params._use_real_and_redshift_space())
             {
               if (space_p=="redshift_space")
                 {
                   So.message_screen("Interpolating galaxy density field on a grid");
                   fftw_functions.get_interpolated_density_field(&s_data_struct_g_marked, false, "any"); // this gives  fftw_functions.field_external
                }
                else if (space_p=="real_space")
                {
                    So.message_screen("Interpolating galaxy density field on a grid");
                    fftw_functions.get_interpolated_density_field_real_space(&s_data_struct_g_marked,false,"any"); // this gives  fftw_functions.field_external
                }
             }
           else if(true==this->params._use_real_and_redshift_space())
             this->fftw_functions.get_interpolated_density_field_real_and_redshift_space(&s_data_struct_g_marked,false, "any");

            primary_field=fftw_functions.field_external;
           fftw_functions.free_fftw_vectors();
            }
         }// end else

       // ************************************************************************************************************
       // ************************************************************************************************************
       // ************************************************************************************************************
       // ************************************************************************************************************
       // ************************************************************************************************************


#ifdef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
         if(true==this->params._set_bins_equal_number_tracers() && tracer._Number_of_tracers_in_mass_bins(im_primary)>0)// if not, read those from the para files as have been provided
#elif defined _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
         if(true==this->params._set_bins_equal_number_tracers() && tracer._Number_of_tracers_in_vmax_bins(im_primary)>0)// if not, read those from the para files as have been provided
#elif defined _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
       if(true==this->params._set_bins_equal_number_tracers() && tracer._Number_of_tracers_in_ph_bins(im_primary)>0)// if not, read those from the para files as have been provided
#endif
         {
         /*
           if(abs(pow(counter_m  - tracer._Number_of_tracers_in_mass_bins(im),2))>0)
           {
           cerr<<RED<<"WARNING: missmatch between number in mass bins at "<<__PRETTY_FUNCTION__<<", line "<<__LINE__<<RESET<<endl;
           cerr<<im<<"  "<< pow(10,this->params._MASSbins_min(im))<<"   "<< pow(10,this->params._MASSbins_max(im))<<"   Current: "<<counter_m<<"  Expected: "<<tracer._Number_of_tracers_in_mass_bins(im)<<endl;
           }
         */




           string nname;
#ifdef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
        nname="massbin";
#endif
#ifdef _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
         nname="vmaxbin";
#endif
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
         nname="nubin";
#endif

        So.message_screen("Identifying bins of secondary properties");
         string file_bins_log = this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".log";
         So.message_screen("Writing bining scheme in file ", file_bins_log );
         ofstream binn_l;binn_l.open(file_bins_log.c_str());

         ofstream binn;
         string file_bins;


         //***********************************************************************
         // Headers
#ifdef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
         binn_l<<"#MASS bin (log10): "<<im_primary<<endl;
         binn_l<<"#logMass min = "<<params._MASSbins_min(im_primary)<<"\tlog Mass max = "<<params._MASSbins_max(im_primary)<<endl;
         binn_l<<"#Number of tracers in current mass bin: "<< tracer._Number_of_tracers_in_mass_bins(im_primary)<<endl;
         binn_l<<"#Number of bins of secondary properties: "<< Nvmax_ind<<"  (0-th: full sample)"<<endl;  // I choose Nvmax_ind as this will be always used.
         binn_l<<"#Number of tracers in bins of secondary properties: "<< tracer._Number_of_tracers_in_mass_bins(im_primary)/(Nvmax_ind-1)<<endl;
#endif
         // Headers
#ifdef _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
         binn_l<<"#VMAX bin (log10): "<<im_primary<<endl;
         binn_l<<"#logVmax min = "<<params._VMAXbins_min(im_primary)<<"\tlog VMax max = "<<params._VMAXbins_max(im_primary)<<endl;
         binn_l<<"#Number of tracers in current vmax bin: "<< tracer._Number_of_tracers_in_vmax_bins(im_primary)<<endl;
         binn_l<<"#Number of bins of secondary properties: "<< Nmass_ind<<endl;  // I choose Nvmax_ind as this will be always used.
         binn_l<<"#Number of tracers in bins of secondary properties: "<< tracer._Number_of_tracers_in_vmax_bins(im_primary)/(Nvmax_ind-1)<<endl;
#endif
         // Headers
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
         binn_l<<"#NU bin (log10): "<<im_primary<<endl;
         binn_l<<"#logNu min = "<<params._PHbins_min(im_primary)<<"\tlog Nu max = "<<params._PHbins_max(im_primary)<<endl;
         binn_l<<"#Number of tracers in current nu bin: "<< tracer._Number_of_tracers_in_ph_bins(im_primary)<<endl;
         binn_l<<"#Number of bins of secondary properties: "<< Nvmax_ind<<endl;  // I choose Nvmax_ind as this will be always used.
         binn_l<<"#Number of tracers in bins of secondary properties: "<< tracer._Number_of_tracers_in_ph_bins(im_primary)/(Nvmax_ind-1)<<endl;
#endif
         //***********************************************************************

        // Let us try that there is at least one object per quartile
        if(tracer._Number_of_tracers_in_mass_bins(im_primary)/(this->params._Number_of_bins_equal_number_tracers()) >= 1 )
        {



#ifndef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
         if(true==bmass)
           {
             binn_l<<"#Mass:"<<endl;
             tracer_aux.get_intervals_equal_number_aux("_MASS_");
             So.message_screen("Writing bining scheme in file ", file_bins );
             for(int i=0;i<tracer_aux.params._Number_of_bins_equal_number_tracers()+1;++i)
               binn_l<<i<<"  "<<tracer_aux.params._MASSbins_min(i)<<"  "<<tracer_aux.params._MASSbins_max(i)<<"\t"<< endl;
           }
#endif
#ifndef _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
         if(true==bvmax)
           {

             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[1];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
             binn_l<<"#Vmax:"<<endl;
             tracer_aux.get_intervals_equal_number_aux("_VMAX_");
             for(int i=0;i<tracer_aux.params._Number_of_bins_equal_number_tracers()+1;++i)
               binn_l<<i<<"  "<<tracer_aux.params._VMAXbins_min(i)<<"  "<<tracer_aux.params._VMAXbins_max(i)<<"\t"<< endl;
             for(int i=0;i<tracer_aux.params._Number_of_bins_equal_number_tracers()+1;++i)
               binn<<i<<"  "<<tracer_aux.params._VMAXbins_min(i)<<"  "<<tracer_aux.params._VMAXbins_max(i)<<"\t"<< endl;
            binn.close();
         }
#endif
         if(true==used_prop[label_rs])
           {
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[2];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
         binn_l<<"#RS:"<<endl;
         tracer_aux.get_intervals_equal_number_aux("_RS_");
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn_l<<i<<"  "<<tracer_aux.params._RSbins_min(i)<<"  "<<tracer_aux.params._RSbins_max(i)<<endl;
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn<<i<<"  "<<tracer_aux.params._RSbins_min(i)<<"  "<<tracer_aux.params._RSbins_max(i)<<endl;
         binn.close();
        }
         if(true==used_prop[label_rvir])
           {
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[3];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
         binn_l<<"#RVIR:"<<endl;
         tracer_aux.get_intervals_equal_number_aux("_RVIR_");
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn_l<<i<<"  "<<tracer_aux.params._RVIRbins_min(i)<<"  "<<tracer_aux.params._RVIRbins_max(i)<<endl;
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn<<i<<"  "<<tracer_aux.params._RVIRbins_min(i)<<"  "<<tracer_aux.params._RVIRbins_max(i)<<endl;
            binn.close();
         }
         if(true==used_prop[label_concentration])
           {
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[4];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
         binn_l<<"#CONCENTRATION:"<<endl;
         tracer_aux.get_intervals_equal_number_aux("_CONCENTRATION_");
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn_l<<i<<"  "<<tracer_aux.params._CONCENTRATIONbins_min(i)<<"  "<<tracer_aux.params._CONCENTRATIONbins_max(i)<<endl;
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn<<i<<"  "<<tracer_aux.params._CONCENTRATIONbins_min(i)<<"  "<<tracer_aux.params._CONCENTRATIONbins_max(i)<<endl;
         binn.close();
        }
         if(true==used_prop[label_spin])
           {
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[5];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
         binn_l<<"#SPIN:"<<endl;
         tracer_aux.get_intervals_equal_number_aux("_SPIN_");
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn_l<<i<<"  "<<tracer_aux.params._SPINbins_min(i)<<"  "<<tracer_aux.params._SPINbins_max(i)<<endl;
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn<<i<<"  "<<tracer_aux.params._SPINbins_min(i)<<"  "<<tracer_aux.params._SPINbins_max(i)<<endl;
         binn.close();
    }
         if(true==used_prop[label_spin_bullock])
           {
             binn_l<<"#SPIN_BULLOCK:"<<endl;
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[6];
             binn.open(file_bins.c_str());
             So.message_screen("Writing bining scheme in file ", file_bins );
          tracer_aux.get_intervals_equal_number_aux("_SPIN_BULLOCK_");
          for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
            binn_l<<i<<"  "<<tracer_aux.params._SPINBULLOCKbins_min(i)<<"  "<<tracer_aux.params._SPINBULLOCKbins_max(i)<<endl;
          for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
            binn<<i<<"  "<<tracer_aux.params._SPINBULLOCKbins_min(i)<<"  "<<tracer_aux.params._SPINBULLOCKbins_max(i)<<endl;
          binn.close();
         }
         if(true==used_prop[label_vrms])
           {
         binn_l<<"#VRMS:"<<endl;
         file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[7];
         binn.open(file_bins.c_str());
         So.message_screen("Writing bining scheme in file ", file_bins );
         tracer_aux.get_intervals_equal_number_aux("_VRMS_");
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn_l<<i<<"  "<<tracer_aux.params._VRMSbins_min(i)<<"  "<<tracer_aux.params._VRMSbins_max(i)<<endl;
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn<<i<<"  "<<tracer_aux.params._VRMSbins_min(i)<<"  "<<tracer_aux.params._VRMSbins_max(i)<<endl;
         binn.close();
        }
         if(true==used_prop[label_virial])
           {
         binn_l<<"#VIRIAL:"<<endl;
         file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[8];
         binn.open(file_bins.c_str());
         So.message_screen("Writing bining scheme in file ", file_bins );
         tracer_aux.get_intervals_equal_number_aux("_VIRIAL_");
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn_l<<i<<"  "<<tracer_aux.params._VIRIALbins_min(i)<<"  "<<tracer_aux.params._VIRIALbins_max(i)<<endl;
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn<<i<<"  "<<tracer_aux.params._VIRIALbins_min(i)<<"  "<<tracer_aux.params._VIRIALbins_max(i)<<endl;
         binn.close();
        }
         if(true==used_prop[label_btoa])
           {
         binn_l<<"#B_TO_A:"<<endl;
         file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[9];
         binn.open(file_bins.c_str());
         So.message_screen("Writing bining scheme in file ", file_bins );
         tracer_aux.get_intervals_equal_number_aux("_BTOA_");
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn_l<<i<<"  "<<tracer_aux.params._BTOAbins_min(i)<<"  "<<tracer_aux.params._BTOAbins_max(i)<<endl;
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn<<i<<"  "<<tracer_aux.params._BTOAbins_min(i)<<"  "<<tracer_aux.params._BTOAbins_max(i)<<endl;
         binn.close();
         }
         if(true==used_prop[label_ctoa])
           {
         binn_l<<"#C_TO_A:"<<endl;
         file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[10];
         binn.open(file_bins.c_str());
         So.message_screen("Writing bining scheme in file ", file_bins );
         tracer_aux.get_intervals_equal_number_aux("_CTOA_");
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn_l<<i<<"  "<<tracer_aux.params._CTOAbins_min(i)<<"  "<<tracer_aux.params._CTOAbins_max(i)<<endl;
         for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
           binn<<i<<"  "<<tracer_aux.params._CTOAbins_min(i)<<"  "<<tracer_aux.params._CTOAbins_max(i)<<endl;
         binn.close();
            }
         if(true==mach)
           {
             binn_l<<"#MACH:"<<endl;
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[11];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
             tracer_aux.get_intervals_equal_number_aux("_MACH_");
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn_l<<i<<"  "<<tracer_aux.params._MACHbins_min(i)<<"  "<<tracer_aux.params._MACHbins_max(i)<<endl;
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn<<i<<"  "<<tracer_aux.params._MACHbins_min(i)<<"  "<<tracer_aux.params._MACHbins_max(i)<<endl;
             binn.close();
           }
         if(true==tbias)
           {
             binn_l<<"#BIAS:"<<endl;
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[12];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
             tracer_aux.get_intervals_equal_number_aux("_BIAS_");
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn_l<<i<<"  "<<tracer_aux.params._BIASbins_min(i)<<"  "<<tracer_aux.params._BIASbins_max(i)<<endl;
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn<<i<<"  "<<tracer_aux.params._BIASbins_min(i)<<"  "<<tracer_aux.params._BIASbins_max(i)<<endl;
             binn.close();
           }
         if(true==tlc)
           {
             binn_l<<"#LC:"<<endl;
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[13];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
             tracer_aux.get_intervals_equal_number_aux("_LOCAL_OVERDENSITY_");
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn_l<<i<<"  "<<tracer_aux.params._LCbins_min(i)<<"  "<<tracer_aux.params._LCbins_max(i)<<endl;
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn<<i<<"  "<<tracer_aux.params._LCbins_min(i)<<"  "<<tracer_aux.params._LCbins_max(i)<<endl;
             binn.close();
           }
         if(true==bta)
           {
             binn_l<<"#TA:"<<endl;
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[14];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
             tracer_aux.get_intervals_equal_number_aux("_TIDAL_ANISOTROPY_");
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn_l<<i<<"  "<<tracer_aux.params._TAbins_min(i)<<"  "<<tracer_aux.params._TAbins_max(i)<<endl;
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn<<i<<"  "<<tracer_aux.params._TAbins_min(i)<<"  "<<tracer_aux.params._TAbins_max(i)<<endl;
             binn.close();
           }
#ifndef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
         if(true==bph)
           {
             binn_l<<"#PH:"<<endl;
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[15];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
             tracer_aux.get_intervals_equal_number_aux("_PEAK_HEIGHT_");
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn_l<<i<<"  "<<tracer_aux.params._PHbins_min(i)<<"  "<<tracer_aux.params._PHbins_max(i)<<endl;
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn<<i<<"  "<<tracer_aux.params._PHbins_min(i)<<"  "<<tracer_aux.params._PHbins_max(i)<<endl;
             binn.close();
           }
#endif

         if(true==dach)
           {
             binn_l<<"#DACH:"<<endl;
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[16];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
             tracer_aux.get_intervals_equal_number_aux("_DACH_");
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn_l<<i<<"  "<<tracer_aux.params._DACHbins_min(i)<<"  "<<tracer_aux.params._DACHbins_max(i)<<endl;
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn<<i<<"  "<<tracer_aux.params._DACHbins_min(i)<<"  "<<tracer_aux.params._DACHbins_max(i)<<endl;
             binn.close();
           }
         if(true==dm_local)
           {
             binn_l<<"#lDM:"<<endl;
             file_bins=this->params._Output_directory()+"BINNING_"+nname+to_string(im_primary)+"_cwt"+to_string(icw)+"_p"+to_string(this->params._unitsim_plabel())+".txt"+prop_name[17];
             So.message_screen("Writing bining scheme in file ", file_bins );
             binn.open(file_bins.c_str());
             tracer_aux.get_intervals_equal_number_aux("_LOCALDM_");
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn_l<<i<<"  "<<tracer_aux.params._LOCALDMbins_min(i)<<"  "<<tracer_aux.params._LOCALDMbins_max(i)<<endl;
             for(int i=0;i<params._Number_of_bins_equal_number_tracers()+1;++i)
               binn<<i<<"  "<<tracer_aux.params._LOCALDMbins_min(i)<<"  "<<tracer_aux.params._LOCALDMbins_max(i)<<endl;
             binn.close();
           }


         binn_l.close();
         So.DONE();


        }//closes if Ntracers/Nbins > Nbins so that at least there is one per quartile

         cout<<endl;

          } //closes  if(true==this->params._set_bins_equal_number_tracers())

       // ----------------------------------------------------- INICIA LOOP SOBRE SECONDARY PROPERTIES

#ifdef  _use_two_quartiles_
#ifdef  _ONLY_CWT_AND_PRIMARY_HBIAS_  // if this is defined, we only go through bin0 for all secondary properties
       vector<int>used_bins{0};
#else
       vector<int>used_bins{0,1,4};
#endif
       vector<int> initial_bin(Number_of_properties,0);//where to start. Initialized to 0: it is updated below if the property is used and if its secondary
       vector<int> N_bins_s(Number_of_properties, 1); // number pf bins. Initialized to 1: it is updated below if the property is used and if its secondary
#endif


    int Nbb=0;
#ifndef _ONLY_CWT_AND_PRIMARY_HBIAS_  // if this is defined, we only go through bin0 for all secondary properties


#ifdef _ASSEMBLY_BIAS_MASS_ONLY_
       int counter_sec=0;// this counter helps to do all 0 bins only once
       // Loop over the total number of properties, regardless whethere these are prim or sec (it will be specified beolos with an if statemen).
       for(int Nbb=0;Nbb<Number_of_properties;++Nbb)
         {
           if(true==secondary_prop[Nbb] && true==used_prop[Nbb])//only valid if these are asked to be used and secondary
         {
            counter_sec++;
#ifndef _use_two_quartiles_
           switch(Nbb)
             {
           Será cuestión de tiempo para verlo.
               //case 0 missing here
             case(1): Nvmax_ind=Nbins_vmax;Nspin_ind=1;Nrs_ind=1;Nvirial_ind=1; Nvrms_ind=1; Nbtoa_ind=1;Nctoa_ind=1; Nmach_ind=1; Nbias_ind=1; Nlc_ind=1;Nta_ind=1;Nph_ind=1; break;
             case(2): Nrs_ind=Nbins_rs;Nvmax_ind=1;Nspin_ind=1;Nvirial_ind=1; Nvrms_ind=1; Nbtoa_ind=1;Nctoa_ind=1;Nmach_ind=1; Nbias_ind=1;Nlc_ind=1;Nta_ind=1;Nph_ind=1;break;
             case(3): Nspin_ind=Nbins_spin;Nvmax_ind=1;Nrs_ind=1;Nvirial_ind=1 ; Nvrms_ind=1;Nbtoa_ind=1;Nctoa_ind=1;Nmach_ind=1; Nbias_ind=1;Nlc_ind=1;Nta_ind=1;Nph_ind=1;break;
             case(4): Nvrms_ind=Nbins_vrms;Nvmax_ind=1;Nrs_ind=1;Nspin_ind=1;Nvirial_ind=1; Nbtoa_ind=1;Nctoa_ind=1;Nmach_ind=1;Nbias_ind=1;Nlc_ind=1;Nta_ind=1;Nph_ind=1;break;
             case(5): Nvirial_ind=Nbins_virial;Nvmax_ind=1;Nrs_ind=1;Nspin_ind=1; Nvrms_ind=1; Nbtoa_ind=1;Nctoa_ind=1;Nmach_ind=1;Nbias_ind=1;Nlc_ind=1;Nta_ind=1;Nph_ind=1;break;
             case(6): Nbtoa_ind=Nbins_btoa;Nvmax_ind=1;Nrs_ind=1;Nspin_ind=1; Nvrms_ind=1;Nvirial_ind=1; Nctoa_ind=1;Nmach_ind=1;Nbias_ind=1; Nlc_ind=1;Nta_ind=1;Nph_ind=1;break;
             case(7): Nctoa_ind=Nbins_ctoa;Nvmax_ind=1;Nrs_ind=1;Nspin_ind=1; Nvrms_ind=1;Nvirial_ind=1; Nbtoa_ind=1;Nmach_ind=1; Nbias_ind=1;Nlc_ind=1;Nta_ind=1;Nph_ind=1;break;
             case(8): Nmach_ind=Nbins_mach;Nvmax_ind=1;Nrs_ind=1;Nspin_ind=1; Nvrms_ind=1;Nvirial_ind=1; Nbtoa_ind=1;Nctoa_ind=1; Nbias_ind=1;Nlc_ind=1;Nta_ind=1;Nph_ind=1;break;
             case(9): Nbias_ind=Nbins_bias;Nvmax_ind=1;Nrs_ind=1;Nspin_ind=1; Nvrms_ind=1;Nvirial_ind=1; Nbtoa_ind=1;Nctoa_ind=1; Nmach_ind=1;Nlc_ind=1;Nta_ind=1;Nph_ind=1;break;
             case(10): Nlc_ind=Nbins_lc;Nvmax_ind=1;Nrs_ind=1;Nspin_ind=1; Nvrms_ind=1;Nvirial_ind=1; Nbtoa_ind=1;Nctoa_ind=1; Nmach_ind=1;Nbias_ind=1;Nta_ind=1;Nph_ind=1;break;
             case(11): Nta_ind=Nbins_ta;Nvmax_ind=1;Nrs_ind=1;Nspin_ind=1; Nvrms_ind=1;Nvirial_ind=1; Nbtoa_ind=1;Nctoa_ind=1; Nmach_ind=1;Nbias_ind=1;Nlc_ind=1;Nph_ind=1;break;
             case(12): Nph_ind=Nbins_ph;Nvmax_ind=1;Nrs_ind=1;Nspin_ind=1; Nvrms_ind=1;Nvirial_ind=1; Nbtoa_ind=1;Nctoa_ind=1; Nmach_ind=1;Nbias_ind=1;Nlc_ind=1;Nta_ind=1;break;
             case(13):aca falta arreglar
             }
#else


           // These lines are meant to do the loops in the secondary propperties covering only the 0 (full) ,1 and 4 quartiles.
           // This first if helps to do all bins 0 only for the first used secondary property.
#ifndef  _ONLY_CWT_AND_PRIMARY_HBIAS_
            if(counter_sec==1)
            {
                     initial_bin[Nbb] = 0;    // Where to start. If the property is not used, we wull never pass through its label so no need for another if
                     N_bins_s[Nbb] = used_bins.size(); // If in the loop over secondary properties you are varying a particular prop, use 0,1,2 bins. Otherwise, the number of bins is 1

            }
           else
               for(int Nab=0;Nab<Number_of_properties;++Nab)
            {
                    initial_bin[Nab] = (Nab==Nbb ? 1 : 0);    // Where to start. If the property is not used, we wull never pass through its label so no need for another if
                    N_bins_s[Nab] = (Nab==Nbb ? used_bins.size(): 1); // If in the loop over secondary properties you are varying a particular prop, use 0,1,2 bins. Otherwise, the number of bins is 1
            }
#endif



#endif // end for _use_two_quartiles_

#endif // end for _ASSEMBLY_BIAS_MASS_ONLY_


#endif // for _ONLY_CWT_AND_PRIMARY_HBIAS_





#ifndef _ONLY_CWT_AND_PRIMARY_HBIAS_  // if this is defined, we only go through bin0 for all secondary properties


#ifdef _use_two_quartiles_
#ifndef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
           for(int qimass=initial_bin[label_mass]; qimass< N_bins_s[label_mass];++qimass) // loop over bins of mass *only if it is secondary*
#endif
#ifndef _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
             for(int qiv=initial_bin[label_vmax]; qiv< N_bins_s[label_vmax];++qiv) // // loop over bins of vmax only if it is secondary
#endif

               for(int qir=initial_bin[label_rs]; qir< N_bins_s[label_rs];++qir) //loop over bins of Rs
                   for(int qirv=initial_bin[label_rvir]; qirv< N_bins_s[label_rvir];++qirv) //loop over bins of Rvir
                       for(int qicon=initial_bin[label_concentration]; qicon< N_bins_s[label_concentration];++qicon) //loop over bins of concentration
             for(int qis=initial_bin[label_spin]; qis< N_bins_s[label_spin];++qis) // loop over bins of spin
                 for(int qisb=initial_bin[label_spin_bullock]; qisb< N_bins_s[label_spin_bullock];++qisb) // loop over bins of spin_bullock
               for(int qirm=initial_bin[label_vrms]; qirm< N_bins_s[label_vrms];++qirm) // loop over bins of VRms
                 for(int qivir=initial_bin[label_virial]; qivir< N_bins_s[label_virial];++qivir) // loop over bins of Virial
                   for(int qiba=initial_bin[label_btoa]; qiba< N_bins_s[label_btoa];++qiba) // loop over bins of b_to_a
                 for(int qica=initial_bin[label_ctoa]; qica< N_bins_s[label_ctoa];++qica) // loop over bins of c_to_a
                   for(int qima=initial_bin[label_mach]; qima< N_bins_s[label_mach];++qima) // loop over bins of mach
                     for(int qibi=initial_bin[label_bias]; qibi< N_bins_s[label_bias];++qibi) // loop over bins of bias
                       for(int qilc=initial_bin[label_lc]; qilc< N_bins_s[label_lc];++qilc) // loop over bins of bias
                     for(int qita=initial_bin[label_ta]; qita< N_bins_s[label_ta];++qita) // loop over bins of tidal_anisotropy
#ifndef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
                       for(int qiph=initial_bin[label_ph]; qiph< N_bins_s[label_ph];++qiph) // loop over bins of nu only if it is not primary
#endif

                         for(int qida=initial_bin[label_da]; qida< N_bins_s[label_da];++qida) // loop over bins of dach number
                             for(int qildm=initial_bin[label_dm_local]; qildm< N_bins_s[label_dm_local];++qildm) // loop over bins of local dm overdenisty (log of)
                           {

#ifndef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
                         int imass=used_bins[qimass];
#endif
#ifndef _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
                         int iv=used_bins[qiv];
#endif
                         int ir= used_bins[qir];
                         int irv= used_bins[qirv];
                         int icon= used_bins[qicon];
                         int is= used_bins[qis];
                         int isb= used_bins[qisb];
                         int irm=used_bins[qirm];
                         int ivir=used_bins[qivir];
                         int iba=used_bins[qiba];
                         int ica=used_bins[qica];
                         int ima=used_bins[qima];
                         int ibi=used_bins[qibi];
                         int ilc=used_bins[qilc];
                         int ita=used_bins[qita];
#ifndef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
                         int iph=used_bins[qiph];
#endif
                         int ida=used_bins[qida];
                         int ildm=used_bins[qildm];

#else //else for _use_two_quartiles_
                         for(int iv=0; iv< Nvmax_ind;++iv) // loop over bins of vmax
                           for(int ir=0; ir< Nrs_ind;++ir) //loop over bins of Rs
                             for(int is=0; is< Nspin_ind;++is) // loop over bins of spin
                               for(int irm=0; irm< Nvrms_ind;++irm) // loop over bins of VRms
                             for(int ivir=0; ivir< Nvirial_ind;++ivir) // loop over bins of Virial
                               for(int iba=0; iba< Nbtoa_ind;++iba) // loop over bins of b_to_a
                                 for(int ica=0; ica< Nctoa_ind;++ica) // loop over bins of c_to_a
                                   for(int ima=0; ima< Nmach_ind;++ima) // loop over bins of mach
                                 for(int ibi=0; ibi< Nbias_ind;++ibi) // loop over bins of bias
                                   for(int ilc=0; ilc< Nlc_ind;++ilc) // loop over bins of bias
                                     for(int ita=0; ita< Nta_ind;++ita) // loop over bins of tidal_anisotropy
                                       for(int iph=0; iph< Nph_ind;++iph) // loop over bins of peak height
                                     for(int ida=0; iph< Nda_ind;++ida) // loop over bins of dach number
                                         for(int ildm=0; ildm< Ndmlocal_ind;++ildm) // loop over bins of dach number
                                       {
#endif // endif for _use_two_quartiles_


#else
    int imass=0;int ir=0;int iv=0;int irv=0;int icon=0; int is=0; int isb=0;int irm=0;int ivir=0; int iba=0; int ica=0; int ima=0; int ibi=0; int ilc=0; int ita=0; int ildm=0; int ida=0;int iph=0;

#endif  // endif for  _ONLY_CWT_AND_PRIMARY_HBIAS_  //




                                         So.message_screen("\tCWT",icw);

                                         So.message_screen("\tProperty label ",Nbb);
                                         So.message_screen("\tProperty name ",prop_name[Nbb]);
                                         cout<<endl;
#ifdef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
                                         So.message_screen("\tMvir bin (PRIMARY)",im_primary);
#else
                                         So.message_screen("\t\tMvir bin",imass);
#endif

#ifdef _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
                                         So.message_screen("\tVMAX (PRIMARY) bin",im_primary);
#else
                                         So.message_screen("\t\tVMAX bin",iv);
#endif
                                         if(this->params._i_rs_g()>0)
                                             So.message_screen("\t\tRs bin",ir);
                                         if(this->params._i_rvir_g()>0)
                                             So.message_screen("\t\tRvir bin",irv);
#ifdef _USE_CONCENTRATION_
                                         if(this->params._i_rs_g()>0 && this->params._i_rvir_g()>0)
                                             So.message_screen("\t\tConcentration bin",icon);
#endif
                                         if(this->params._i_spin_g()>0)
                                             So.message_screen("\t\tSpin bin ",is);
                                         if(this->params._i_spin_bullock_g()>0)
                                             So.message_screen("\t\tSpinB bin ",isb);
                                         if(this->params._i_vrms_g()>0)
                                             So.message_screen("\t\tVrms bin ",irm);
                                         if(this->params._i_virial_g()>0)
                                             So.message_screen("\t\tVirial bin ",ivir);
                                         if(this->params._i_b_to_a_g()>0)
                                             So.message_screen("\t\tb2a bin ",iba);
                                         if(this->params._i_c_to_a_g()>0)
                                             So.message_screen("\t\tc2a bin ",ica);
                                         if(this->params._Get_tracer_local_mach_number() ==true)
                                             So.message_screen("\t\tmach bin ",ima);
                                         if(this->params._Get_tracer_bias() ==true)
                                             So.message_screen("\t\tbias bin ",ibi);
                                         if(this->params._Get_local_overdensity() ==true)
                                             So.message_screen("\t\tLC bin ",ilc);
                                         if(this->params._Get_tidal_anisotropy_at_halo() ==true)
                                            So.message_screen("\t\tTA bin ",ita);
#ifdef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
                                         So.message_screen("\tPH (PRIMARY) bin ",im_primary);
#else
                                         if(this->params._Get_peak_height_at_halo() ==true)
                                             So.message_screen("\t\tPH bin ",iph);
#endif
                                         if(this->params._Get_tracer_local_dach_number() ==true)
                                             So.message_screen("\t\tdach bin ",ida);

                                         if(this->params._Get_tracer_local_dm_density() ==true)
                                             So.message_screen("\t\tlog (delta dm +1) bin ",ildm);


#ifdef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
                                         int ph_index=iph;
                                         int vmax_index=iv;
                                         int mass_index=im_primary;
#elif defined _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
                                         int ph_index=iph;
                                         int vmax_index=im_primary;
                                         int mass_index=imass;
#elif defined _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
                                         int ph_index=im_primary;
                                         int vmax_index=iv;
                                         int mass_index=imass;
#endif


                                          string extra_info="_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_nubin"+to_string(ph_index)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm)+"_cwc"+to_string(icw);

                                          string extra_info_dm="_DM_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_nubin"+to_string(ph_index)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm)+"_cwc"+to_string(icw);
#ifdef _USE_CWC_HALO_ANALYSIS_
                                         this->file_power=file_pow+extra_info;
                                         this->file_power_cross=file_pow_cross+extra_info;

                                         string file_field=this->params._Output_directory()+"halo_field_Nres_"+to_string(this->params._Nft())+extra_info;
#else
                                         if(false==this->params._set_bins_equal_number_tracers())
                                           {
                                         this->file_power=file_pow+"_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_massbin"+to_string(ph_index)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm)+"_fixedbins";
                                         string file_field=this->params._Output_directory()+"halo_field_Nres_"+to_string(this->params._Nft())+"_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_nubin"+to_string(ph_index)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm)+"_fixedbins";
                                           }
                                         else
                                           {
                                         this->file_power=file_pow+"_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_massbin"+to_string(iph)+"_dabin"+"_ldmbin"+to_string(ildm)+to_string(ida);
                                         string file_field=this->params._Output_directory()+"halo_field_Nres_"+to_string(this->params._Nft())+"_massbin"+to_string(im)+"_vmaxbin"+to_string(iv)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_nubin"+to_string(iph)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm);

                                           }
#endif

                                         string file_contours =this->params._Output_directory()+"halo_field_Nres_"+to_string(this->params._Nft())+extra_info;
                                         string file_hist = this->params._Output_directory()+"halo_field_Nres_"+to_string(this->params._Nft())+extra_info;


                                         ofstream blss;
                                         ofstream blssc;
#ifdef _USE_CWC_HALO_ANALYSIS_
                                         string file_lss_bias=this->params._Output_directory()+"lss_bias"+extra_info;
                                         string file_lss_bias_cross=this->params._Output_directory()+"lss_bias_cross"+extra_info;
                                         string file_lss_bias_object=this->params._Output_directory()+"lss_bias_object"+extra_info;

#else
                                         string file_lss_bias=this->params._Output_directory()+"lss_bias_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_phbin"+to_string(ph_index)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm);
#endif
                                         blss.open(file_lss_bias.c_str());
                                         blssc.open(file_lss_bias_cross.c_str());

                                         Catalog tracer_final(this->params);

                                         ULONG in_new=0;  // counter for sub sample

                                         real_prec bias_from_objects=0;
                                         vector<real_prec>bias_ob;

                                         // We select now properties in bins of secondary properties. Selection in CWT and Mass has been already imposed in the tracer_aux catalog.
                                         for(ULONG i=0;i<tracer_aux.Halo.size();++i)
                                         {
#ifndef _USE_MASS_AS_PRIMARY_PROPERTY_HBIAS_
                                           if(log10(tracer_aux.Halo[i].mass)>= tracer_aux.params._MASSbins_min(mass_index) && log10(tracer_aux.Halo[i].mass) < tracer_aux.params._MASSbins_max(mass_index))
#endif
#ifndef _USE_VMAX_AS_PRIMARY_PROPERTY_HBIAS_
                                         if(log10(tracer_aux.Halo[i].vmax)>= tracer_aux.params._VMAXbins_min(vmax_index) && log10(tracer_aux.Halo[i].vmax)< tracer_aux.params._VMAXbins_max(vmax_index))
#endif
                                           if(tracer_aux.Halo[i].rs>= tracer_aux.params._RSbins_min(ir) && tracer_aux.Halo[i].rs< tracer_aux.params._RSbins_max(ir))
                                               if(tracer_aux.Halo[i].rvir>= tracer_aux.params._RVIRbins_min(irv) && tracer_aux.Halo[i].rvir< tracer_aux.params._RVIRbins_max(irv))
                                                   if(tracer_aux.Halo[i].concentration>= tracer_aux.params._CONCENTRATIONbins_min(icon) && tracer_aux.Halo[i].concentration< tracer_aux.params._CONCENTRATIONbins_max(icon))
                                               if(tracer_aux.Halo[i].spin>= tracer_aux.params._SPINbins_min(is) && tracer_aux.Halo[i].spin< tracer_aux.params._SPINbins_max(is))
                                                   if(tracer_aux.Halo[i].spin_bullock>= tracer_aux.params._SPINBULLOCKbins_min(isb) && tracer_aux.Halo[i].spin_bullock< tracer_aux.params._SPINBULLOCKbins_max(isb))
                                               if(tracer_aux.Halo[i].vrms>= tracer_aux.params._VRMSbins_min(irm) && tracer_aux.Halo[i].vrms< tracer_aux.params._VRMSbins_max(irm))
                                             if(tracer_aux.Halo[i].virial>= tracer_aux.params._VIRIALbins_min(ivir) && tracer_aux.Halo[i].virial< tracer_aux.params._VIRIALbins_max(ivir))
                                               if(tracer_aux.Halo[i].b_to_a>= tracer_aux.params._BTOAbins_min(iba) && tracer_aux.Halo[i].b_to_a< tracer_aux.params._BTOAbins_max(iba))
                                                 if(tracer_aux.Halo[i].c_to_a>= tracer_aux.params._CTOAbins_min(ica) && tracer_aux.Halo[i].c_to_a< tracer_aux.params._CTOAbins_max(ica))
                                                   if(tracer_aux.Halo[i].mach_number>= tracer_aux.params._MACHbins_min(ima) && tracer_aux.Halo[i].mach_number< tracer_aux.params._MACHbins_max(ima))
                                                 if(tracer_aux.Halo[i].bias>= tracer_aux.params._BIASbins_min(ibi) && tracer_aux.Halo[i].bias< tracer_aux.params._BIASbins_max(ibi))
                                                   if(tracer_aux.Halo[i].local_overdensity>= tracer_aux.params._LCbins_min(ilc) && tracer_aux.Halo[i].local_overdensity< tracer_aux.params._LCbins_max(ilc))
                                                     if(tracer_aux.Halo[i].tidal_anisotropy>= tracer_aux.params._TAbins_min(ita) && tracer_aux.Halo[i].tidal_anisotropy< tracer_aux.params._TAbins_max(ita))
#ifndef _USE_PEAK_HEIGHT_AS_PRIMARY_PROPERTY_HBIAS_
                                                       if(tracer_aux.Halo[i].peak_height>= tracer_aux.params._PHbins_min(ph_index) && tracer_aux.Halo[i].peak_height< tracer_aux.params._PHbins_max(ph_index))
#endif

                                                     if(tracer_aux.Halo[i].dach_number>= tracer_aux.params._DACHbins_min(ida) && tracer_aux.Halo[i].dach_number< tracer_aux.params._DACHbins_max(ida))
                                                         if(tracer_aux.Halo[i].local_dm>= tracer_aux.params._LOCALDMbins_min(ida) && tracer_aux.Halo[i].local_dm< tracer_aux.params._LOCALDMbins_max(ida))
                                                       {
                                                         tracer_final.Halo.push_back(s_Halo());//Push back new subject created with default constructor.
                                                         tracer_final.Halo[in_new].coord1=tracer_aux.Halo[i].coord1;
                                                         tracer_final.Halo[in_new].coord2=tracer_aux.Halo[i].coord2;
                                                         tracer_final.Halo[in_new].coord3=tracer_aux.Halo[i].coord3;
                                                         tracer_final.Halo[in_new].mass=tracer_aux.Halo[i].mass;
                                                         tracer_final.Halo[in_new].vmax=tracer_aux.Halo[i].vmax;
                                                         tracer_final.Halo[in_new].rs=tracer_aux.Halo[i].rs;
                                                         tracer_final.Halo[in_new].rvir=tracer_aux.Halo[i].rvir;
                                                         tracer_final.Halo[in_new].concentration=tracer_aux.Halo[i].concentration;
                                                         tracer_final.Halo[in_new].spin=tracer_aux.Halo[i].spin;
                                                         tracer_final.Halo[in_new].spin_bullock=tracer_aux.Halo[i].spin_bullock;
                                                         tracer_final.Halo[in_new].vrms=tracer_aux.Halo[i].vrms;
                                                         tracer_final.Halo[in_new].virial=tracer_aux.Halo[i].virial;
                                                         tracer_final.Halo[in_new].b_to_a=tracer_aux.Halo[i].b_to_a;
                                                         tracer_final.Halo[in_new].c_to_a=tracer_aux.Halo[i].c_to_a;
                                                         tracer_final.Halo[in_new].mach_number=tracer_aux.Halo[i].mach_number;
                                                         tracer_final.Halo[in_new].bias=tracer_aux.Halo[i].bias;
                                                         tracer_final.Halo[in_new].local_overdensity=tracer_aux.Halo[i].local_overdensity;
                                                         tracer_final.Halo[in_new].tidal_anisotropy=tracer_aux.Halo[i].tidal_anisotropy;
                                                         tracer_final.Halo[in_new].peak_height=tracer_aux.Halo[i].peak_height;
                                                         tracer_final.Halo[in_new].dach_number=tracer_aux.Halo[i].dach_number;
                                                         bias_from_objects+=tracer_aux.Halo[i].bias;
                                                         bias_ob.push_back(tracer_aux.Halo[i].bias);
                                                         tracer_final.Halo[in_new].vel1=tracer_aux.Halo[i].vel1;
                                                         tracer_final.Halo[in_new].vel2=tracer_aux.Halo[i].vel2;
                                                         tracer_final.Halo[in_new].vel3=tracer_aux.Halo[i].vel3;
                                                         tracer_final.Halo[in_new].local_dm=tracer_aux.Halo[i].local_dm;
                                                         in_new++;
                                                       }
                                             }


                                         cout<<endl;
                                         So.message_screen("\tNumber of tracers selected in bin of secondary property =",in_new);

                             //            string file_ntracers = this->params._Output_directory()+"Ntracers_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_phbin"+to_string(ph_index)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm)+"_cwc"+to_string(icw);
                             //            So.message_screen("Saving number of tracers in file", file_ntracers);
                             //            ofstream ntr; ntr.open(file_ntracers.c_str());
                             //            ntr<<in_new<<endl;
                             //            ntr.close();
                             //            So.DONE();
                                         tracer_final.set_NOBJS(in_new);// IMPORTANT. OTHERWISE METHODS OF tracer_aux WILL SEE DEFAULT VALUE NOBS=0

                                         cout<<endl;

                                         if(in_new>0)
                                           {
                                         // ************************************************************************************************ //
                                             if(true==this->params._Get_tracer_bias())
                                             {
                                                 So.message_screen("\tComputing population bias and writting in file =", file_lss_bias_object);
                                                  if(in_new>0)
                                                     bias_from_objects/=static_cast<real_prec>(in_new);
                                                  real_prec e_bias=sqrt(get_var(bias_from_objects,bias_ob));
                                                 ofstream nb; nb.open(file_lss_bias_object.c_str());
                                                 nb<<bias_from_objects<<"\t"<<e_bias<<endl;
                                                 nb.close();
                                                 So.DONE();
                                                 cout<<endl;
                                             }




                                             if(true==this->params._Get_pearson_coefficient())
                                            {
                                             // *Compute the pearson coefficients among halo proeprties. This is the intrinsic correlation *//
                                         ofstream pearsout;
                                         ofstream pearsout_b;
                                         string file_pearson_intrinsic;
                                         string file_pearson_bias;
                                         if(false==this->params._set_bins_equal_number_tracers())
                                           {
                                             file_pearson_intrinsic=this->params._Output_directory()+"pearson_coef_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_ldmbin"+to_string(ildm)+"_fixedbins";

                                           }
                                         else
                                         {
#ifdef _USE_CWC_HALO_ANALYSIS_
                                           file_pearson_intrinsic=this->params._Output_directory()+"pearson_coef_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_nubin"+to_string(ph_index)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm)+"_cwc"+to_string(icw);
                                           file_pearson_bias=this->params._Output_directory()+"bias_pearson_coef_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_nubin"+to_string(ph_index)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm)+"_cwc"+to_string(icw);

#else
                                         file_pearson_intrinsic=this->params._Output_directory()+"pearson_coef_massbin"+to_string(im)+"_vmaxbin"+to_string(iv)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_nubin"+to_string(iph)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm);

#endif
                                         }
                                         So.message_screen("\tComputing Pearson coefficient in file", file_pearson_intrinsic );

                                         vector<real_prec>b_p;
                                         pearsout.open(file_pearson_intrinsic.c_str());
                                         for(int ka=0;ka<prop_name.size();++ka)
                                           {
                                             for(int kb=ka+1;kb<prop_name.size();++kb)
                                               {
                                                 real_prec pearson_c=tracer_final.pearson_correlation(prop_name[ka],prop_name[kb]);
                                                 pearsout<<prop_name[ka]<<"\t"<<prop_name[kb]<<"\t"<<pearson_c<<endl;
                                                 if(prop_name[kb]=="_BIAS_" || prop_name[ka]=="_BIAS_")
                                                    b_p.push_back(pearson_c);
                                             }
                                           }
                                         pearsout.close();

                                         pearsout_b.open(file_pearson_bias.c_str());
                                         for(int ka=0;ka<b_p.size();++ka)
                                             pearsout_b<<ka<<"  "<<b_p[ka]<<endl;
                                         pearsout_b.close();
                                         b_p.clear();b_p.shrink_to_fit();


                                         So.DONE();
                                         }// close if get pearson

                                          if(true==this->params._Get_spearman_coefficient())
                                           {


                                              ofstream spearman;
                                              ofstream spearman_b;
                                              string file_spearman_intrinsic;
                                              string file_spearman_bias;
                                              file_spearman_intrinsic=this->params._Output_directory()+"spearman_coef_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_nubin"+to_string(ph_index)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm)+"_cwc"+to_string(icw);
                                              file_spearman_bias=this->params._Output_directory()+"bias_spearman_coef_massbin"+to_string(mass_index)+"_vmaxbin"+to_string(vmax_index)+"_rsbin"+to_string(ir)+"_rvirbin"+to_string(irv)+"_concentrationbin"+to_string(icon)+"_spinbin"+to_string(is)+"_spinbullockbin"+to_string(isb)+"_vrmsbin"+to_string(irm)+"_virialbin"+to_string(ivir)+"_btoabin"+to_string(iba)+"_ctoabin"+to_string(ica)+"_machbin"+to_string(ima)+"_biasbin"+to_string(ibi)+"_lcbin"+to_string(ilc)+"_tabin"+to_string(ita)+"_nubin"+to_string(ph_index)+"_dabin"+to_string(ida)+"_ldmbin"+to_string(ildm)+"_cwc"+to_string(icw);
                                              vector<real_prec>b_p;

                                              So.message_screen("\tComputing Spearman-rank coefficient in file", file_spearman_intrinsic );

                                              for(int ka=0;ka<prop_name.size();++ka)
                                                 tracer_final.Get_Ranked_Props(prop_name[ka]);

                                              spearman.open(file_spearman_intrinsic.c_str());
                                              for(int ka=0;ka<prop_name.size();++ka)
                                                {
                                                  for(int kb=ka+1;kb<prop_name.size();++kb)
                                                    {
                                                      real_prec pearson_c=tracer_final.spearman_correlation(prop_name[ka],prop_name[kb]);
                                                      spearman<<prop_name[ka]<<"\t"<<prop_name[kb]<<"\t"<<pearson_c<<endl;
                                                      if(prop_name[kb]=="_BIAS_" || prop_name[ka]=="_BIAS_")
                                                        b_p.push_back(pearson_c);
                                                    }
                                                 }
                                               spearman.close();
                                               spearman_b.open(file_spearman_bias.c_str());
                                               for(int ka=0;ka<b_p.size();++ka)
                                                  spearman_b<<ka<<"  "<<b_p[ka]<<endl;
                                               spearman_b.close();
                                               b_p.clear();b_p.shrink_to_fit();
                                               tracer_final.Halo_ranked.clear();
                                               tracer_final.Halo_ranked.shrink_to_fit();

                                          }
                                         // ************************************************************************************************ //
                                         // ************************************************************************************************ //
                                         // ************************************************************************************************ //
                                          // ************************************************************************************************ //
                                        if(this->params._Get_PCA())
                                             {

					       So.message_screen("Doing PCA");
					       tracer_final.PCA(prop_name, used_prop,extra_info, false);
					       So.DONE();
					     }
					     // ************************************************************************************************ //
					     
					     if(true==this->params._Get_power_spectrum())
					       {
					      
					      this->File.input_type=this->params._input_type();
					      this->N_galaxy=in_new;
					      real_prec mean_density=static_cast<real_prec>(in_new)/pow(this->params._Lbox(),3);
					      s_data_structure s_data_struct_g;
					      s_data_struct_g.properties=tracer_final.Halo;
					      s_data_struct_g.system_of_coordinates=this->params._sys_of_coord_g();
					      s_data_struct_g.mean_density=mean_density;
					      s_data_struct_g.catalog="data";
					      tracer_final.Halo.clear();tracer_final.Halo.shrink_to_fit();
					      this->fftw_functions.set_n_gal(in_new);
					      this->fftw_functions.resize_fftw_vectors();
#ifdef _VERBOSE_POWER_
					      this->fftw_functions.write_fftw_parameters();
					      So.message_screen("Interpolating galaxy density field on a grid");
#endif
					      if (false==this->params._use_real_and_redshift_space())
						{
						  if (space_p=="redshift_space")
						    this->fftw_functions.get_interpolated_density_field(&s_data_struct_g, false, "any");
						  else if (space_p=="real_space")
						    {
						      this->fftw_functions.get_interpolated_density_field_real_space(&s_data_struct_g,false, "any");
						    }
						}
					      
					      else if (true==this->params._use_real_and_redshift_space())
						this->fftw_functions.get_interpolated_density_field_real_and_redshift_space(&s_data_struct_g,false, "any");

					      // *****************************************************************************************
					      if(true==this->params._write_files_for_histograms())
						{
						  this->File.write_array(file_field,this->fftw_functions.field_external);
						  vector<real_prec>aux_field (this->fftw_functions.field_external.size(),0);
						  get_overdens(this->fftw_functions.field_external,aux_field);
						  vector<real_prec>Vaux(Nbins*Nbins,0);
						  get_2d_histogram(this->params._ldelta_X_min(),this->params._ldelta_X_max(),this->params._ldelta_Y_min(),this->params._ldelta_Y_max(),Nbins, DM_DEN_FIELD, aux_field,Vaux,true);
						  this->File.write_array(file_hist,Vaux);
						  this->mcmc.get_contour_levels(file_contours+"_contour_levels",Nbins, Vaux);
						  Vaux.clear();Vaux.shrink_to_fit();
						}
					      // *****************************************************************************************
					      So.message_screen("\tComputing Prop-power");
					      this->fftw_functions.raw_sampling(pow(this->params._Lbox(),3));
					      this->fftw_functions.get_parameters_estimator(true);
					      if(true==this->params._use_real_and_redshift_space())
                            this->fftw_functions.get_fluctuation(true);
                         else
                            this->fftw_functions.get_fluctuation();
                         // *****************************************************************************************
                         kvector_data.clear(); // Bins here are linear by default
                         kvector_data.shrink_to_fit();
                         for(ULONG i=0;i<this->params._d_Nnp_data();i++)
                           kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
                         if (true==this->params._use_real_and_redshift_space())
                         {
                            this->pk.clear();
                            this->pk.shrink_to_fit();
                            this->pk.resize(this->params._d_Nnp_data(),0); // Real space
                         }

                         this->pk0.clear();
                         this->pk0.shrink_to_fit();
                         this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
                         this->pk2.resize(this->params._d_Nnp_data(),0); //Quadrupole
                         this->pk4.resize(this->params._d_Nnp_data(),0); //Hexadecapole

                         this->modes_g.clear();
                         this->modes_g.shrink_to_fit();
                         this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance
                         this->pk_w.clear();
                         this->pk_w.shrink_to_fit();
                         this->pk_w.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance
                         if (false==this->params._use_real_and_redshift_space())
                           {
                             fftw_functions.get_power_spectrum_fkp(this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);
                             this->write_power_spectrum(false); // argument asks to write sigma or not
                           }
                         else
                        {
                          fftw_functions.get_power_spectrum_fkp(this->pk,this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);
                          this->File.write_to_file(this->file_power,this->kvector_data,this->pk, this->pk0,this->pk2,this->pk4,this->modes_g);
                        }
					 
                                         // *****************************************************************************************
                                         if(true==this->params._Get_cross_power_spectrum())
					   {
					     // Measure cross correlation between halo full population and sub-population
					     So.message_screen("\tComputing cross power spectrum between primary and secondary selected tracers");
                    //     this->compute_cross_power_spectrum_grid(false, this->fftw_functions.field_external, primary_field, true);
					     // Measure cross correlation between DM field and sub-population
					     this->file_power_cross=file_pow_cross+extra_info_dm;
                         this->compute_cross_power_spectrum_grid(true, DM_DEN_FIELD, this->fftw_functions.field_external,true);
					     
                         pair<real_prec, real_prec>lss_bias_cpower=this->get_lss_cross_bias(this->pk0, power_dm, this->kvector_data, this->modes_g, 2, this->params._kmax_tracer_bias()); // 0.08
                         pair<real_prec, real_prec>lss_bias_cpower2=this->get_lss_cross_bias(this->pk0, power_dm, this->kvector_data, this->modes_g, 2, 0.06);
                         pair<real_prec, real_prec>lss_bias_cpower3=this->get_lss_cross_bias(this->pk0, power_dm, this->kvector_data, this->modes_g, 2, 0.04);

                         So.message_screen("\tLarge scale bias from cross power =", lss_bias_cpower.first);
                         blssc<<lss_bias_cpower.first<<"\t"<<lss_bias_cpower.second<<"\t"<<lss_bias_cpower2.first<<"\t"<<lss_bias_cpower2.second<<"\t"<<lss_bias_cpower3.first<<"\t"<<lss_bias_cpower3.second<<endl;
					     So.DONE();
					     blssc.close();
					   }
					 
					 
					 // *****************************************************************************************
                                         if(Nbb !=Number_of_properties) //this means, free memory except the last pass, for it will be done directly by the destructor and it compaints if it finds nothing to free
                                           fftw_functions.free_fftw_vectors();


					 // *****************************************************************************************
                                         // *****************************************************************************************
                                         // here we need to cpmpute kmax as Min(this->params._kmax_tracer_bias() and k such that P=0.1Pshot)
					 
                                         real_prec shot_noise=pow(this->params._Lbox(),3)/static_cast<real_prec>(in_new); // Poisson Shot noise
					 
                                         int ik=1;//to avoid zero mode
                                         while(this->pk[ik]>=SN_TOLERANCE_HBIAS*shot_noise)
                                           ++ik;
					 
                                         int initial_kmode=2;
                                         real_prec kmax_sn=min(this->params._kmax_tracer_bias(),this->kvector_data[ik]);
                                         real_prec kmax_sn2=min(static_cast<real_prec>(0.06),this->kvector_data[ik]);
                                         real_prec kmax_sn3=min(static_cast<real_prec>(0.04),this->kvector_data[ik]);
                                         if(kmax_sn>=this->kvector_data[initial_kmode])// this prevents that bias is computed from a shot-noise dominated signal
                                           {
					     
                                             this->So.message_screen("\tMaximum wave-number before shot-noise dominance:",this->kvector_data[ik]);
                                             this->So.message_screen("\tShot-noise:", shot_noise);
                                             this->So.message_screen("\tTolerance power ", SN_TOLERANCE_HBIAS*shot_noise);
                                             this->So.message_screen("\tMaximum wave-number for bias calculation ", kmax_sn);
					     
                                             pair<real_prec, real_prec>lss_bias_power=this->get_lss_bias(this->pk, power_dm, this->kvector_data, this->modes_g, initial_kmode, kmax_sn);
                                             pair<real_prec, real_prec>lss_bias_power2=this->get_lss_bias(this->pk, power_dm, this->kvector_data, this->modes_g, initial_kmode, kmax_sn2);
                                             pair<real_prec, real_prec>lss_bias_power3=this->get_lss_bias(this->pk, power_dm, this->kvector_data, this->modes_g, initial_kmode, kmax_sn3);
                                             So.message_screen("\tLarge scale bias =", lss_bias_power.first);
                                             blss<<lss_bias_power.first<<"\t"<<lss_bias_power.second<<"\t"<<lss_bias_power2.first<<"\t"<<lss_bias_power2.second<<"\t"<<lss_bias_power3.first<<"\t"<<lss_bias_power3.second<<endl;
                                             So.DONE();
                                             blss.close();
                                           }
					 else
                                           this->So.message_screen("\t\tP(k) dominated by shot-noise. LSS bias is not computed");
					 cout<<endl;
                                         // *****************************************************************************************

                                         // *****************************************************************************************


					 
                                         }//cloess do power, andres

                                           }// closes if number of tracers>0

#ifndef _ONLY_CWT_AND_PRIMARY_HBIAS_  // if this is defined, we only go through bin0 for all secondary properties
                                       }// closes loop of bins or cuts, in particualr, loop over bin of  c_to_a
#ifdef _ASSEMBLY_BIAS_MASS_ONLY_
                           }//closes if properties are seconday and used
         }//closes loop over N bins of properties
#endif
#endif

         }//closes loop over primary properties
#ifdef _USE_CWC_HALO_ANALYSIS_
       }//closes loop over CTW
#endif
    this->So.message_time(time_POWER);

 }
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************


// This tries to unify the functions compute_power_spectrum_bam_real_space or _redshift_space in seveal bins of halo properties as given by the input parameter file.

// We need to extend this to other properties, adding lists to the parameter fies.
// we can also write in binary files the CIC interpolation of the halo number counts
// such that we can plot the bias in 2d using the density field of the DM as well


void PowerSpectrumF::compute_marked_power_spectrum(string space_p){

#ifdef _VERBOSE_POWER_
  this->So.enter(__PRETTY_FUNCTION__);
#endif


  time_t start;
  time (&start);
#ifdef _USE_OMP_
   int NTHREADS=_NTHREADS_;
   omp_set_num_threads(NTHREADS);
#endif

   // **************************************************************************************************
  Catalog tracer(params);
  tracer.read_catalog(params._Input_dir_cat()+params._file_catalogue(),0);
  this->set_params(tracer.params); // params has been updated inside the catalog class.

  // **************************************************************************************************
  // **************************************************************************************************
    //fix file names

  string file_pearson_enviromental=this->params._Output_directory()+"pearson_coef_env.txt";
  // **************************************************************************************************

  ULONG Nbins=this->params._Nbins_hist();

  string file_pow;
  if (space_p=="redshift")
    file_pow=this->file_power_redshift_space;
  else
    file_pow=this->file_power_real_space;

  // *Get the total number of propertye bis* //
  int Nbins_mass=this->params._NMASSbins_power();


  vector<real_prec>variance_property;
  vector<real_prec>mean_prop;
  vector<string>prop_name;
  int Nbins_vmax=this->params._NVMAXbins_power();
  prop_name.push_back("_VMAX_");
  int Nbins_rs=this->params._NRSbins_power();
  prop_name.push_back("_RS_");
  int Nbins_spin=this->params._NSPINbins_power();
  prop_name.push_back("_SPIN_");
  int Nbins_vrms=this->params._NVRMSbins_power();
  prop_name.push_back("_VRMS_");
  int Nbins_virial=this->params._NVIRIALbins_power();
  prop_name.push_back("_VIRIAL_");
  int Nbins_btoa=this->params._NBTOAbins_power();
  prop_name.push_back("_BTOA_");
  int Nbins_ctoa=this->params._NCTOAbins_power();
  prop_name.push_back("_CTOA_");
  int Number_of_properties=prop_name.size();


  So.message_screen("Number of bins in mass=", Nbins_mass);
  // **************************************************************************************************
  int Ncwt=0;
  vector<real_prec> DM_DEN_FIELD( this->params._NGRID(),0);
  this->File.read_array(this->params._Input_Directory_X()+this->params._Name_Catalog_X(),DM_DEN_FIELD);
  this->pk0.clear();
  this->pk0.shrink_to_fit();
  this->params.set_input_type("density_grid");
  this->params.set_Name_survey("DM");
  this->params.set_SN_correction(true);
  this->params.set_MAS_correction(false);
  string file_aux=this->file_power;
  this->file_power=this->params._Output_directory()+"Pk_DM_p"+to_string(this->params._unitsim_plabel())+".txt";
  this->compute_power_spectrum_grid(DM_DEN_FIELD, true);
  this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
  vector<real_prec>power_dm(this->params._d_Nnp_data(),0);
  for(ULONG i=0;i<power_dm.size();++i)
    power_dm[i]=this->pk0[i];

  get_overdens(DM_DEN_FIELD,DM_DEN_FIELD);
#ifdef _USE_CWC_HALO_ANALYSIS_
  // We can here read the dark matter density field and determine the CWC
  Cwclass cwclass(this->params);
  cwclass.get_CWC(DM_DEN_FIELD);
  Ncwt=cwclass.cwt_used.size();
  So.message_screen("Number cosmic-web types=", Ncwt);
#endif
  this->params.set_Name_survey("HALOS");
  this->params.set_SN_correction(true);
  this->params.set_mass_assignment_scheme("CIC");
  this->file_power=file_aux;
  // **************************************************************************************************


#ifdef _USE_CWC_HALO_ANALYSIS_
  for(int ict=0;ict<Ncwt;ict++)  // loop over nuber of cosmic-web types
    {
#endif
      for(int im=0; im< Nbins_mass;++im) // loop over bins of mass
    {
      Catalog tracer_aux(this->params);
      // if the bins are to be defined with same number of objects, here is the place to redefine those bins for each mass bin
      // using inside this loop the  members f the params class setbins*()
      if(true==this->params._set_bins_equal_number_tracers())
        {
          // *Selecting the trabcers and its propertis in each mass bin*//
          ULONG counter_m=0;
          for(ULONG i=0;i<tracer._NOBJS();++i)
        if(tracer.Halo[i].mass>= pow(10,this->params._MASSbins_min(im)) && tracer.Halo[i].mass< pow(10,this->params._MASSbins_max(im)))
          {
            tracer_aux.Halo.push_back(s_Halo());
            tracer_aux.Halo[counter_m].coord1 = tracer.Halo[i].coord1;
            tracer_aux.Halo[counter_m].coord2 = tracer.Halo[i].coord2;
            tracer_aux.Halo[counter_m].coord3 = tracer.Halo[i].coord3;
            tracer_aux.Halo[counter_m].vel1 = tracer.Halo[i].vel1;
            tracer_aux.Halo[counter_m].vel2 = tracer.Halo[i].vel2;
            tracer_aux.Halo[counter_m].vel3 = tracer.Halo[i].vel3;
            tracer_aux.Halo[counter_m].mass = tracer.Halo[i].mass;
            tracer_aux.Halo[counter_m].vmax = tracer.Halo[i].vmax;
            tracer_aux.Halo[counter_m].rs = tracer.Halo[i].rs;
            tracer_aux.Halo[counter_m].spin = tracer.Halo[i].spin;
            tracer_aux.Halo[counter_m].vrms = tracer.Halo[i].vrms;
            tracer_aux.Halo[counter_m].virial = tracer.Halo[i].virial;
            tracer_aux.Halo[counter_m].b_to_a = tracer.Halo[i].b_to_a;
            tracer_aux.Halo[counter_m].c_to_a = tracer.Halo[i].c_to_a;
            tracer_aux.Halo[counter_m].GridID = tracer.Halo[i].GridID;
            counter_m++;
          }


                  if(abs(pow(counter_m  - tracer._Number_of_tracers_in_mass_bins(im),2))>0)
                    {
                      cerr<<RED<<"WARNING: missmatch between number in mass bins at "<<__PRETTY_FUNCTION__<<", line "<<__LINE__<<RESET<<endl;
                      cerr<<im<<"  "<< pow(10,this->params._MASSbins_min(im))<<"   "<< pow(10,this->params._MASSbins_max(im))<<"   Current: "<<counter_m<<"  Expected: "<<tracer._Number_of_tracers_in_mass_bins(im)<<endl;
                    }

          So.message_screen("Computing mean and var");

          for(int Nba=0;Nba<Number_of_properties;++Nba){
            pair<real_prec,real_prec>stats=tracer_aux.get_variance(prop_name[Nba],false);// false means that it gives <prop²> istead of <(prop-mean)²>
            mean_prop.push_back(stats.first);
            variance_property.push_back(stats.second/pow(stats.first,2));
          }

          for(ULONG i=0;i<tracer_aux.Halo.size();++i)// Ojo con el orden. Here we normalize paroperties to their mean
                    {
              tracer_aux.Halo[i].vmax /= mean_prop[0];
              tracer_aux.Halo[i].rs /= mean_prop[1];
              tracer_aux.Halo[i].spin /= mean_prop[2];
              tracer_aux.Halo[i].vrms /= mean_prop[3];
              tracer_aux.Halo[i].virial /= mean_prop[4];
              tracer_aux.Halo[i].b_to_a /= mean_prop[5];
              tracer_aux.Halo[i].c_to_a /= mean_prop[6];
                    }

                  this->set_params(tracer_aux.params); // update the params, for it has been modified in the tracer_aux method
                }


          ofstream blss;
          string file_lss_bias=this->params._Output_directory()+"LSS_markedBIAS_massbin"+to_string(im)+".txt";
          blss.open(file_lss_bias.c_str());


          for(int Nbb=0;Nbb<Number_of_properties;++Nbb)
        { // loop over the properties to be uses as weigts.

          So.message_screen("Computing power spectrum of property:", prop_name[Nbb]);


#ifdef _USE_CWC_HALO_ANALYSIS_
          this->file_power=file_pow+"_massbin"+to_string(im)+"_mark"+prop_name[Nbb];
          string file_field=this->params._Output_directory()+"halo_field_Nres_"+to_string(this->params._Nft())+"_massbin"+to_string(im)+"_mark"+prop_name[Nbb];
#else
          this->file_power=file_pow+"_massbin"+to_string(im)+"_mark"+prop_name[Nbb];
          string file_field=this->params._Output_directory()+"marked_halo_field_Nres_"+to_string(this->params._Nft())+"_massbin"+to_string(im)+"_mark"+prop_name[Nbb];
#endif
          string file_contours = file_field+"_contours";
          string file_hist = file_field+"_hist";


#ifdef _USE_CWC_HALO_ANALYSIS_
          So.message_screen("CWT      =",ict);
#endif
          So.message_screen("Mass bin=",im);
          So.message_screen("Number of tracers selected (in power func)=",tracer_aux.Halo.size());

          this->File.input_type=this->params._input_type();
                  this->N_galaxy=tracer_aux.Halo.size();
          real_prec mean_density=static_cast<real_prec>(tracer_aux.Halo.size())/pow(this->params._Lbox(),3);
          s_data_structure s_data_struct_g;
          s_data_struct_g.properties=tracer_aux.Halo;
          s_data_struct_g.system_of_coordinates=this->params._sys_of_coord_g();
          s_data_struct_g.mean_density=mean_density;
          s_data_struct_g.catalog="data";

                  fftw_functions.set_n_gal(tracer_aux.Halo.size());
#ifdef _VERBOSE_POWER_
                  fftw_functions.write_fftw_parameters();
#endif
          vector<real_prec>delta(this->params._NGRID(),0);
          vector<real_prec>w_delta(this->params._NGRID(),0);

          if (space_p=="redshift")
            {
              So.message_screen("Interpolating weighted galaxy density field on a grid for", prop_name[Nbb]);
                      fftw_functions.get_interpolated_density_field(&s_data_struct_g, true, prop_name[Nbb]);// this gives  fftw_functions.field_external_marked
                      w_delta=fftw_functions.field_external;
              So.message_screen("Interpolating galaxy density field on a grid");
                      fftw_functions.get_interpolated_density_field(&s_data_struct_g, false, "any"); // this gives  fftw_functions.field_external
                      delta=fftw_functions.field_external;
            }
          else
            {
              So.message_screen("Interpolating weighted galaxy density field on a grid for", prop_name[Nbb]);
                      fftw_functions.field_external.clear();
                      fftw_functions.get_interpolated_density_field_real_space(&s_data_struct_g,true, prop_name[Nbb]); // this gives  fftw_functions.field_external_marked
                      w_delta=fftw_functions.field_external;
              So.message_screen("Interpolating galaxy density field on a grid");
                      fftw_functions.field_external.clear();
                      fftw_functions.get_interpolated_density_field_real_space(&s_data_struct_g,false,"any"); // this gives  fftw_functions.field_external
                      delta=fftw_functions.field_external;
            }

          // *****************************************************************************************
                  this->File.write_array(file_field,fftw_functions.field_external_marked);
                  vector<real_prec>aux_field (fftw_functions.field_external.size(),0);
                  get_overdens(fftw_functions.field_external_marked,aux_field);
          vector<real_prec>Vaux(Nbins*Nbins,0);
          get_2d_histogram(this->params._ldelta_X_min(),this->params._ldelta_X_max(),this->params._ldelta_Y_min(),this->params._ldelta_Y_max(),Nbins, DM_DEN_FIELD, aux_field,Vaux,true);
          this->File.write_array(file_hist,Vaux);
          this->mcmc.get_contour_levels(file_contours+"_contour_levels",Nbins, Vaux);
          // *****************************************************************************************
                  fftw_functions.resize_fftw_vectors();
                  fftw_functions.raw_sampling(pow(this->params._Lbox(),3));
                  fftw_functions.get_parameters_estimator(true);
          real_prec nmean=static_cast<real_prec>(tracer_aux.Halo.size())/static_cast<real_prec>(this->params._NGRID()); // mean number of tracers in cells

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
          for(ULONG i=0;i<this->params._NGRID();++i)
                    fftw_functions.set_data_g(i, (static_cast<real_prec>(w_delta[i])-static_cast<real_prec>(delta[i]))/static_cast<real_prec>(nmean));

          w_delta.clear();w_delta.shrink_to_fit();
          delta.clear();delta.shrink_to_fit();
                  real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
                  fftw_functions.set_normal_power(pow(factor,-2));
                  fftw_functions.set_shot_noise((variance_property[Nbb] -1.0)/static_cast<real_prec>(nmean));

          kvector_data.clear();
          kvector_data.shrink_to_fit();
          if(this->params._type_of_binning()=="linear")
            {
              for(ULONG i=0;i<this->params._d_Nnp_data();i++)
            kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
            }
          else
            {
              if(this->params._type_of_binning()=="log")
            {
              for(ULONG i=0;i<kvector_data.size();i++)
                kvector_data.push_back(this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal()));
            }
            }
          this->pk0.clear();
          this->pk0.shrink_to_fit();
          this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
                  //this->pk2.resize(this->params._d_Nnp_data(),0); //Quadrupole
                  //this->pk4.resize(this->params._d_Nnp_data(),0); //Hexadecapole
                  this->modes_g.clear();
          this->modes_g.shrink_to_fit();
          this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance
                  this->pk_w.clear();
                  this->pk_w.shrink_to_fit();
                  this->pk_w.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance
                  fftw_functions.get_power_spectrum_fkp(this->pk0,this->pk2,this->pk4,this->pk_w,this->pkk,this->pmk,this->modes_g);
                  //this->write_power_spectrum(false); // argument asks to write sigma or not

          real_prec lss_bias=0;
          ULONG kcount=0;

          int ik=1;//to avoid zeros
                  while(this->kvector_data[ik]<this->params._kmax_tracer_bias())
            {
              lss_bias+=sqrt(this->pk0[ik]/power_dm[ik]);
              ++ik;
              kcount++;
            }
          lss_bias/=kcount;
          So.message_screen("Large scale bias =", lss_bias);

          blss<<lss_bias<<endl;
          So.DONE();
        }
          blss.close();
        }
#ifdef _USE_CWC_HALO_ANALYSIS_
        }
#endif
}
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************

 void PowerSpectrumF::compute_marked_power_spectrum_grid(const vector<real_prec> &data_in,const vector<real_prec> &data_in_MW)
 {

#ifdef _VERBOSE_POWER_
   this->So.enter(__PRETTY_FUNCTION__);
#endif

#ifdef _USE_OMP_
   int NTHREADS=_NTHREADS_;
   omp_set_num_threads(NTHREADS);
#endif

   fftw_functions.resize_fftw_vectors();

   real_prec ngal_new=get_nobjects(data_in);

   real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
   for(ULONG i=0;i<this->params._NGRID();++i)
     fftw_functions.data_g[i]=(static_cast<real_prec>(data_in_MW[i])-static_cast<real_prec>(data_in[i]))/static_cast<real_prec>(nmean);

   this->params.set_ngal_delta(ngal_new);
   fftw_functions.set_n_gal(ngal_new);

   real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
   fftw_functions.set_normal_power(pow(factor,-2));
   fftw_functions.shot_noise=(this->var_prop-1.0)*static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);

   kvector_data.resize(this->params._d_Nnp_data(), 0);
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
   for(int i=0;i<this->params._d_Nnp_data();i++)
     kvector_data[i]=this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5);

   this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
   this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance

#if !defined _USE_BIAS_OBJECT_TO_OBJECT_ || !defined (_USE_CROSS_CORRELATION_CONF_SPACE_)
   fftw_functions.power_spectrum(this->pk0,this->modes_g);
#else
   //we're done, no pwoer haja
#endif

#ifdef _USE_GNUPLOT_POWER_
   this->gp.plot_power_spectrum(this->kvector_data,this->pk0);
#endif


 }


 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************-u INIT_PARS_UNITSIM/cosmicatlas_new_unitsim_p65.ini************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 void PowerSpectrumF::compute_power_spectrum_grid()
 {


#ifdef _VERBOSE_POWER_
   this->So.enter(__PRETTY_FUNCTION__);
#endif


#ifdef _USE_OMP_
   int NTHREADS=_NTHREADS_;
   omp_set_num_threads(NTHREADS);
#endif

   vector<real_prec> data_in(this->params._NGRID(),0);
   So.message_screen("Reading input file on a mesh, with precision set by PrecType_Y directive");
   this->File.read_array_t<PrecType_Y>(this->params._delta_grid_file(), data_in);
   fftw_functions.resize_fftw_vectors();
#ifdef _FULL_VERBOSE_
   fftw_functions.write_fftw_parameters();
#endif
#ifdef _NCUTS_POWER_
   string ofile=this->file_power;
   for(int Ni=0;Ni<N_MAX_OCCUPATION;Ni+=2)
     {
#endif

#ifdef _NCUTS_POWER_
       if(this->params._input_type()=="density_grid")
     for(ULONG i=0;i<this->params._NGRID();++i)
       if(data_in[i]<Ni)
         data_in[i]=0;
       else
         if(this->params._input_type()=="dela_grid")
           for(ULONG i=0;i<this->params._NGRID();++i)
         if(data_in[i]<Ni)
           data_in[i]=-1;
#endif




       real_prec ngal_new=get_nobjects(data_in);

       if(this->params._input_type()=="density_grid")
#ifdef _VERBOSE_POWER_
     So.message_screen("Number of objects =",ngal_new);
#endif

       if(this->params._input_type()=="density_grid")
     {
       real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
       for(ULONG i=0;i<this->params._NGRID();++i)
             fftw_functions.data_g[i]=(static_cast<real_prec>(data_in[i])/static_cast<real_prec>(nmean))-1.;
     }
       else
     {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
       for(ULONG i=0;i<this->params._NGRID();++i)
             fftw_functions.data_g[i]=data_in[i];
     }


       this->params.set_ngal_delta(ngal_new);
       fftw_functions.set_n_gal(ngal_new);

       real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
       fftw_functions.set_normal_power(pow(factor,-2));

       fftw_functions.shot_noise=0;
       if(true==this->params._SN_correction())
         fftw_functions.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);
#ifdef _VERBOSE_POWER_
       So.message_screen("Shot Noise =",fftw_functions.shot_noise);
       So.message_screen("Normalization =",fftw_functions._normal_power());
#endif

       this->kvector_data.resize(this->params._d_Nnp_data(), 0);

       if("linear" == this->params._type_of_binning())
     {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
       for(int i=0;i<this->params._d_Nnp_data();i++)
         this->kvector_data[i]=this->params._d_kmin()+ this->params._d_DeltaK_data()*(i+0.5);

     }
       else if("log"==this->params._type_of_binning())
     {
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
       for(int i=0;i<this->params._d_Nnp_data();i++)
         this->kvector_data[i]=this->params._d_kmin()*pow(10,(i-0.5)*this->params._d_Deltal());
     }


       this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
       this->modes_g.resize(this->params._d_Nnp_data(),0); //Needed in case we use the Veff for the variance
#if  !defined (_USE_CROSS_CORRELATION_CONF_SPACE_)
       fftw_functions.power_spectrum(this->pk0,this->modes_g);
#endif



#ifdef _NCUTS_POWER_
       this->file_power=ofile+"_Ncuts"+to_string(Ni);
#endif


       write_power_and_modes();

#ifdef _USE_GNUPLOT_POWER_
       this->gp.plot_power_spectrum(this->kvector_data,this->pk0);
#endif


#ifdef _NCUTS_POWER_
     }
#endif

 }

// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// *******************************************************************          *********************************************************************************************************************************************
// *****************************************************************************    ***********************************************************************************************************************************
void PowerSpectrumF::get_window_matrix_multipole()
{
// This function provids the window matrix which in reality is a tensor of 4 indices:
// two indices for multipoles l, l': these can be from 0 to 4, usually 0,2,4
// two indices for wavenumber modes, k and k': k runs over the bins used in the measurements,
// while k' (kp) runs oer the modes implemented in the Gauss -legendre integration.
// This computation involves a double rum over the random catalog.



  this->set_N_random(100);


  // ------------------------------------------------------------------------
  if(true==this->params._FKP_weight())
#ifdef _USE_OMP_
#pragma omp parlalel for
#endif
    for (ULONG i=0; i<this->N_random;++i)
      this->random_cat.Halo[i].weight1=1./(1+this->params._Pest()*this->random_cat.Halo[i].mean_density);
  else
#ifdef _USE_OMP_
#pragma omp parlalel for
#endif
    for (ULONG i=0; i<this->N_random;++i)
      this->random_cat.Halo[i].weight1=1.;
  this->alpha=1;//fftw_functions.alpha;
  this->normal_power=1;//fftw_functions.normal_power;
  // ------------------------------------------------------------------------

  // Compute here the squared of the distance to the origin d² for each random tracer
  vector<real_prec>distances_cat(this->N_random,0);
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
  for (ULONG i=0; i<this->N_random;++i)
    distances_cat[i]=pow(this->random_cat.Halo[i].coord1,2)+pow(this->random_cat.Halo[i].coord2,2)+pow(this->random_cat.Halo[i].coord3,2);
  // ------------------------------------------------------------------------
  for(int i=0;i<this->params._d_Nnp_data();i++)
    this->kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
  // ------------------------------------------------------------------------
  vector<real_prec>kvector_data_GL(GAUSS_LEGANDERE_NODES_INTEGRATION,0);
  vector<real_prec>weight_GL(GAUSS_LEGANDERE_NODES_INTEGRATION,0);
  gsl_get_GL_weights(this->params._d_kmin(),this->params._d_kmax(), kvector_data_GL, weight_GL);

  // ------------------------------------------------------------------------

  real_prec window=0;
  real_prec pre_factor=2.0*pow(this->alpha,2)/pow(this->normal_power,2);


  ULONG Npairs=this->N_random*(this->N_random-1)/2;
#ifdef _FULL_VERBOSE_
  this->So.message_screen("Building pair indices");
  this->So.message_screen("Number of paris =", Npairs);
#endif

  struct pair_info{
    ULONG index_i;
    ULONG index_j;
    real_prec Rplus;
    real_prec Rminus;
  };

  vector<pair_info> pairs(Npairs);

  ULONG counter=0;
  for (ULONG i=0; i<this->N_random;++i)
     for (ULONG j=i+1; j<this->N_random;++j)
      {
        pairs[counter].index_i=i;
        pairs[counter].index_j=j;
        pairs[counter].Rplus=sqrt(pow(this->random_cat.Halo[i].coord1+this->random_cat.Halo[j].coord1,2)+pow(this->random_cat.Halo[i].coord2+this->random_cat.Halo[j].coord2,2)+pow(this->random_cat.Halo[i].coord3+this->random_cat.Halo[j].coord3,2));
        pairs[counter].Rminus=sqrt(pow(this->random_cat.Halo[i].coord1-this->random_cat.Halo[j].coord1,2)+pow(this->random_cat.Halo[i].coord2-this->random_cat.Halo[j].coord2,2)+pow(this->random_cat.Halo[i].coord3-this->random_cat.Halo[j].coord3,2));
        counter++;
    }
  So.DONE();

#ifdef _FULL_VERBOSE_
  this->So.message_screen("Starting");
#endif


  this->window_matrix.resize(kvector_data_GL.size()*kvector_data.size()*MAXIMUM_MULTIPOLE_POWER,0);

  for (int l=0;l<MAXIMUM_MULTIPOLE_POWER;++l)              // Loop over multipole
    {
      pre_factor*=(2*l+1);
      this->So.message_screen("l =", l);
      for (ULONG nk=0;nk<this->kvector_data.size();nk++)    // Loop over wavenumbers of measured power
    {
      for (ULONG nkp=0;nkp<kvector_data_GL.size() ;nkp++)            //Loop over wanvenumbers GS integration
        {
          pre_factor*=weight_GL[nkp]*kvector_data_GL[nkp]*kvector_data_GL[nkp];
          real_prec window=0;
          for (int lp=0;lp<MAXIMUM_MULTIPOLE_POWER;++lp)              //Loop over multipole
        {
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+: window)
#endif
          for (ULONG ip=0; ip<Npairs;++ip)
            {
              ULONG i=pairs[ip].index_i;
              ULONG j=pairs[ip].index_j;
              real_prec Rplus= pairs[ip].Rplus;
              real_prec Rminus=pairs[ip].Rminus;
              real_prec bess1=gsl_sf_bessel_jl(l,this->kvector_data[nk]*Rminus);
              real_prec bess2=gsl_sf_bessel_jl(lp,kvector_data_GL[nkp]*Rminus);
              real_prec deltaR=(distances_cat[i]-distances_cat[j])/(Rplus*Rminus) ;
              real_prec w1=this->random_cat.Halo[i].weight1 * gsl_sf_legendre_Pl(l,deltaR);
              real_prec w2=this->random_cat.Halo[j].weight1 * gsl_sf_legendre_Pl(lp,deltaR);
              window+=pre_factor*w1*w2*bess1*bess2;
            }
        }
          this->window_matrix[index_3d(l,nk,nkp,kvector_data.size(),kvector_data_GL.size())]=window;  // formar un vector,
        }
    }
    }

  this->So.DONE();

}




// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************
// ****************************************************************************************************************************************************************************************************************

#ifdef _USE_CROSS_CORRELATION_CONF_SPACE_
 void PowerSpectrumF::get_cross_correlation_config_space(vector<real_prec>& X,vector<real_prec>& Y,vector<real_prec>& corr){

#ifdef _FULL_VERBOSE_
   this->So.enter(__PRETTY_FUNCTION__);
#endif


   this->params.set_measure_cross(true);
   this->params.set_input_type("density_grid");
   this->params.set_input_type_two("density_grid");
   this->params.set_SN_correction(false);


   this->fftw_functions.set_params(this->params);

   s_parameters_box s_p_box;

   real_prec ngal_new=0;
   fftw_functions.data_g.clear();
   fftw_functions.data_g.shrink_to_fit();
   fftw_functions.data_g.resize(this->params._NGRID(),0);

#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new)
#endif
   for(ULONG i=0;i<this->params._NGRID();++i)
     ngal_new+=static_cast<real_prec>(Y[i]);
   real_prec nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
   for(ULONG i=0;i<this->params._NGRID();++i)
     fftw_functions.data_g[i]=(static_cast<real_prec>(Y[i])/static_cast<real_prec>(nmean))-1.;
   this->params.set_ngal_delta(ngal_new);


   if(true==this->params._SN_correction())
     fftw_functions.shot_noise=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);

   real_prec factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
   fftw_functions.set_normal_power(pow(factor,-2));
   fftw_functions.data_gp.clear();
   fftw_functions.data_gp.shrink_to_fit();
   fftw_functions.data_gp.resize(this->params._NGRID(),0);
   ngal_new=0;

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
   for(ULONG i=0;i<this->params._NGRID();++i)
     fftw_functions.data_gp[i]=static_cast<real_prec>(X[i]);


#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:ngal_new)
#endif
   for(ULONG i=0;i<this->params._NGRID();++i)
     ngal_new+=static_cast<real_prec>(X[i]);
   nmean=static_cast<real_prec>(ngal_new)/static_cast<real_prec>(this->params._NGRID());

#ifdef _USE_OMP_
#pragma omp parallel for
#endif
   for(ULONG i=0;i<this->params._NGRID();++i)
     fftw_functions.data_gp[i]=(static_cast<real_prec>(X[i])/static_cast<real_prec>(nmean))-1.;

   fftw_functions.shot_noise2=0;
   factor=pow(static_cast<real_prec>(this->params._Lbox()),1.5)/static_cast<real_prec>(fftw_functions.data_g.size());
   fftw_functions.set_normal_power_two(pow(factor,-2));


   bool dm=true;
   if(false==dm && true==this->params._SN_correction())
     fftw_functions.shot_noise2=static_cast<real_prec>(pow(this->params._Lbox(),3))/static_cast<real_prec>(ngal_new);

   fftw_functions.resize_fftw_vectors();
   this->pk0.clear();
   this->pk0.shrink_to_fit();
   this->pk0.resize(this->params._d_Nnp_data(),0); //Monopole
   this->modes_g.clear();
   this->modes_g.resize(this->params._d_Nnp_data(),0); //Monopole
   fftw_functions.cross_power_spectrum_fkp(this->pk0,this->modes_g,corr);

 }
#endif


 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************

 void PowerSpectrumF::object_by_object_bias(vector<s_Halo>& tracer_cat, vector<real_prec>& dm_field){


   // ---------------------------------------------------
   // The power spectrum of the DM has been computed before the call of this method
   // and is still allocated in the container this->pk0
   // ---------------------------------------------------


#ifdef _FULL_VERBOSE_
   this->So.enter(__PRETTY_FUNCTION__);
#endif

#ifdef _FULL_VERBOSE_
   this->So.message_screen("Getting object-to-object bias");
#endif


#if defined _TNG_ || defined _TNG_GAL_
     kvector_data.clear();
     kvector_data.shrink_to_fit();
     for(int i=0;i<this->params._d_Nnp_data();i++)
       kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
#endif



#ifdef _USE_OMP_
   int NTHREADS=_NTHREADS_;
   omp_set_num_threads(NTHREADS);
#endif

   // Given kmax, determine the maximum number of bins requested
   ULONG Kmax_bin=static_cast<ULONG>(floor((this->params._kmax_tracer_bias()-this->params._d_kmin())/this->params._d_DeltaK_data()));//get the bin to go only up to Kmax in the loops
   // ---------------------------------------------------
   // Define the new Nft=2*Kmax_bin
   ULONG new_Nft=2*Kmax_bin;

   // ---------------------------------------------------
   ULONG new_ngrid_h =new_Nft*new_Nft*(new_Nft/2+1);
#ifdef DOUBLE_PREC
   complex_prec * Delta_dm = (complex_prec *)fftw_malloc(2*new_ngrid_h*sizeof(real_prec));
#else
//    complex_prec * Delta_dm =(complex_prec *)fftwf_malloc(2*new_ngrid_h*sizeof(real_prec));
    complex_prec * Delta_dm =(complex_prec *)fftwf_malloc(2*this->params._NGRID_h()*sizeof(real_prec));
#endif

   // ---------------------------------------------------
   // Get the Fourier transform of the dm filed alreay filtered
//   low_pass_filter(this->params._Nft(),new_Nft,1,false,dm_field,Delta_dm,params._Lbox());

    real_prec mean_field=get_mean(dm_field);
    So.message_screen("\tMean of field:", mean_field);
    get_overdens(dm_field,mean_field,dm_field);


    So.message_screen("\tFourier transforming");
    do_fftw_r2c(this->params._Nft(),dm_field,Delta_dm);
   // ---------------------------------------------------
   // Build k-coordinates
   vector<real_prec> kcoords(new_Nft,0);
#ifdef _USE_OMP_
#pragma omp parallel for
#endif
   for(int i=0;i<kcoords.size() ;++i)
    kcoords[i]=(i<=new_Nft/2? static_cast<real_prec>(i): -static_cast<real_prec>(new_Nft-i));
   // ---------------------------------------------------
   ULONG initial_mode=3;
#ifdef _FULL_VERBOSE_
   this->So.message_screen("\tNew Nft ",new_Nft);
   this->So.message_screen("\tComputing from k =", (initial_mode+0.5)*this->params._d_DeltaK_data());
   this->So.message_screen("\t            to k =", this->params._kmax_tracer_bias());
#endif
   // ---------------------------------------------------
   real_prec use_imag=0;
  // This is the normalization of the halo power spectrum, which being computed object-by object, is just the volume
   // FOr the full sample it would be the volume/Ntracer, = nbar. But Ntracer =1 for each object!
   real_prec vol=pow(this->params._Lbox(),3);

   // This is the normalization of the cross power spectrum, sqrt(normal_1 * normal_2), and norma_1=normal_2

   real_prec normal_dm= sqrt(vol)/static_cast<real_prec>(this->params._NGRID());
   real_prec normal_h =static_cast<real_prec>(1./vol);
   real_prec normal_cross= 1; //normal_dm * normal_h;
   real_prec dk_x=this->params._d_deltak_x();
   real_prec dk_y=this->params._d_deltak_y();
   real_prec dk_z=this->params._d_deltak_z();


   this->So.message_screen("\tGetting power dark matter");
  // This is done once for all tracers
   vector<real_prec>power_dmat(Kmax_bin,0);

#ifdef _USE_OMP_
#pragma omp parallel for collapse(3)
#endif
   for(ULONG i=initial_mode; i< new_Nft/2;++i)
     for(ULONG j=initial_mode; j< new_Nft/2;++j)
         for(ULONG k=initial_mode; k< new_Nft/2+1;++k)
         {
           ULONG lp=index_3d(i,j,k,this->params._Nft(),this->params._Nft()/2+1);
           real_prec  kv=sqrt(pow(dk_x*kcoords[i],2)+pow(dk_y*kcoords[j],2)+pow(dk_z*kcoords[k],2));
           ULONG kbin=static_cast<ULONG>(floor((kv-this->params._d_kmin())/this->params._d_DeltaK_data()));
           if(lp!=0)
             if(kbin<Kmax_bin)
#ifdef _USE_OMP_
#pragma omp atomic
#endif
                 power_dmat[kbin]+=(Delta_dm[lp][REAL]*Delta_dm[lp][REAL]+Delta_dm[lp][IMAG]*Delta_dm[lp][IMAG]);
           /****************************************************************/
           if(j>0  && k>0)
             {
               lp=index_3d(i,this->params._Nft()-j,k,this->params._Nft(),this->params._Nft()/2+1);
               if(kbin<Kmax_bin)
#ifdef _USE_OMP_
#pragma omp atomic
#endif
                 power_dmat[kbin]+=(Delta_dm[lp][REAL]*Delta_dm[lp][REAL]+Delta_dm[lp][IMAG]*Delta_dm[lp][IMAG]);
            }
           /****************************************************************/
           if(i>0  && (j>0 || k>0))
             {
               lp=index_3d(this->params._Nft()-i,j,k,this->params._Nft(),this->params._Nft()/2+1);
               if(kbin<Kmax_bin)
#ifdef _USE_OMP_object_b
#pragma omp atomic
#endif
                   power_dmat[kbin]+=(Delta_dm[lp][REAL]*Delta_dm[lp][REAL]+Delta_dm[lp][IMAG]*Delta_dm[lp][IMAG]);
             }
           /****************************************************************/
             if(i>0  && j>0  && k>0)
             {
               lp=index_3d(this->params._Nft()-i,this->params._Nft()-j,k,this->params._Nft(),this->params._Nft()/2+1);
               if(kbin<Kmax_bin)
#ifdef _USE_OMP_
#pragma omp atomic
#endif
                   power_dmat[kbin]+=(Delta_dm[lp][REAL]*Delta_dm[lp][REAL]+Delta_dm[lp][IMAG]*Delta_dm[lp][IMAG]);
             }
         }

    So.DONE();

     real_prec conversion_factor=(1.+this->params._redshift())/(this->cosmology.Hubble_function(this->params._redshift(), (void *)&this->params.s_cosmo_pars));

#ifdef _UNITSIM_
    real_prec kmax_b=0.06;
    real_prec kmax_c=0.04;
#elif defined _TNG_GAL_
     real_prec kmax_b=0.25;
     real_prec kmax_c=0.2;
#endif

     real_prec lss_bias_halo=0;
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:lss_bias_halo)
#endif
   for(ULONG itr=0;itr<tracer_cat.size();++itr)
     {
        real_prec xtracer=tracer_cat[itr].coord1;
        real_prec ytracer=tracer_cat[itr].coord2;
        real_prec ztracer=tracer_cat[itr].coord3;
#ifndef _TNG_GAL_
        real_prec vx=tracer_cat[itr].vel1*conversion_factor;
#endif
        vector<real_prec>power_cross(Kmax_bin,0);
#ifndef _TNG_GAL_
       vector<real_prec>power_cross_s(Kmax_bin,0);
       vector<real_prec>Gamma_num(Kmax_bin,0);
#endif

       //*******   The cross power spectrum has real and imaginary parts. C=A+iB.If the fieidsl are not properly correlated, the imaginary parts will be non-zero
       //*******   I.e, for perfectly correlated fields, B== and the cross pwoer is C=A.
       //*******   Now, for bias. we compare the bias b_1 fro the one measured with power spectrum b²=Phh/Pmm.
       //*******   while here, with the cross, we compute b = Phm/Pmm. This is chosen as Phm is decomposed in delta_dm * exp(-ikr)


       // Loop over the Fourier box up to the maximum k (bin) used to get bias
       for(ULONG i=initial_mode; i< new_Nft/2;++i)
         for(ULONG j=initial_mode; j< new_Nft/2;++j)
             for(ULONG k=initial_mode; k< new_Nft/2+1;++k)
             {
               ULONG lp=index_3d(i,j,k,this->params._Nft(),this->params._Nft()/2+1);
               real_prec k_dot_r=0;
               real_prec k_dot_s=0;
               real_prec  kv=sqrt(pow(dk_x*kcoords[i],2)+pow(dk_y*kcoords[j],2)+pow(dk_z*kcoords[k],2));
               ULONG kbin=static_cast<ULONG>(floor((kv-this->params._d_kmin())/this->params._d_DeltaK_data()));
               /****************************************************************/
               if(lp!=0)
               {
                 k_dot_r=dk_x*kcoords[i]*xtracer + dk_y*kcoords[j]*ytracer + dk_z*kcoords[k]*ztracer;
#ifndef _TNG_GAL_
                 k_dot_s=dk_x*kcoords[i]*(xtracer+vx) + dk_y*kcoords[j]*ytracer + dk_z*kcoords[k]*ztracer;
#endif
                 if(kbin<Kmax_bin){
                     power_cross[kbin]+=(cos(k_dot_r)*Delta_dm[lp][REAL]-sin(k_dot_r)*Delta_dm[lp][IMAG]);
#ifndef _TNG_GAL_
                     power_cross_s[kbin]+=(cos(k_dot_s)*Delta_dm[lp][REAL]-sin(k_dot_s)*Delta_dm[lp][IMAG]);
                     Gamma_num[kbin]+=(cos(k_dot_r)*Delta_dm[lp][REAL]-sin(k_dot_r)*Delta_dm[lp][IMAG])*pow(cos(dk_x*kcoords[i]/kv),2);
#endif
                 }

                 }
               /****************************************************************/
               if(j>0  && k>0)
                 {
                   lp=index_3d(i,this->params._Nft()-j,k,this->params._Nft(),this->params._Nft()/2+1);
                   k_dot_r=dk_x*kcoords[i]*xtracer + dk_y*kcoords[new_Nft-j]*ytracer + dk_z*kcoords[k]*ztracer;
#ifndef _TNG_GAL_
                   k_dot_s=dk_x*kcoords[i]*(xtracer+vx) + dk_y*kcoords[j]*ytracer + dk_z*kcoords[k]*ztracer;
#endif
                   if(kbin<Kmax_bin){
                     power_cross[kbin]+=(cos(k_dot_r)*Delta_dm[lp][REAL]-sin(k_dot_r)*Delta_dm[lp][IMAG]);
#ifndef _TNG_GAL_
                     power_cross_s[kbin]+=(cos(k_dot_s)*Delta_dm[lp][REAL]-sin(k_dot_s)*Delta_dm[lp][IMAG]);
                     Gamma_num[kbin]+=(cos(k_dot_r)*Delta_dm[lp][REAL]-sin(k_dot_r)*Delta_dm[lp][IMAG])*pow(cos(dk_x*kcoords[i]/kv),2);
#endif
                   }
                   }
               /****************************************************************/
               if(i>0  && (j>0 || k>0))
                 {
                   lp=index_3d(this->params._Nft()-i,j,k,this->params._Nft(),this->params._Nft()/2+1);
                   k_dot_r=dk_x*kcoords[new_Nft-i]*xtracer + dk_y*kcoords[j]*ytracer + dk_z*kcoords[k]*ztracer;
#ifndef _TNG_GAL_
                   k_dot_s=dk_x*kcoords[i]*(xtracer+vx) + dk_y*kcoords[j]*ytracer + dk_z*kcoords[k]*ztracer;
#endif
                   if(kbin<Kmax_bin){
                       power_cross[kbin]+=(cos(k_dot_r)*Delta_dm[lp][REAL]-sin(k_dot_r)*Delta_dm[lp][IMAG]);
#ifndef _TNG_GAL_
                       power_cross_s[kbin]+=(cos(k_dot_s)*Delta_dm[lp][REAL]-sin(k_dot_s)*Delta_dm[lp][IMAG]);
                       Gamma_num[kbin]+=(cos(k_dot_r)*Delta_dm[lp][REAL]-sin(k_dot_r)*Delta_dm[lp][IMAG])*pow(cos(dk_x*kcoords[i]/kv),2);
#endif
                   }
               }
               /****************************************************************/
                 if(i>0  && j>0  && k>0)
                 {
                   lp=index_3d(this->params._Nft()-i,this->params._Nft()-j,k,this->params._Nft(),this->params._Nft()/2+1);
                   k_dot_r=dk_x*kcoords[new_Nft-i]*xtracer+dk_y*kcoords[new_Nft-j]*ytracer + dk_z*kcoords[k]*ztracer;
#ifndef _TNG_GAL_
                   k_dot_s=dk_x*kcoords[i]*(xtracer+vx) + dk_y*kcoords[j]*ytracer + dk_z*kcoords[k]*ztracer;
#endif
                   if(kbin<Kmax_bin)
                   {
                       power_cross[kbin]+=(cos(k_dot_r)*Delta_dm[lp][REAL]-sin(k_dot_r)*Delta_dm[lp][IMAG]);
#ifndef _TNG_GAL_
                       power_cross_s[kbin]+=(cos(k_dot_s)*Delta_dm[lp][REAL]-sin(k_dot_s)*Delta_dm[lp][IMAG]);
                       Gamma_num[kbin]+=(cos(k_dot_r)*Delta_dm[lp][REAL]-sin(k_dot_r)*Delta_dm[lp][IMAG])*pow(cos(dk_x*kcoords[i]/kv),2);
#endif

                   }
                  }
                 /****************************************************************/
             }

        real_prec power_hm=0;
        real_prec power_hm2=0;
        real_prec power_hm3=0;
        real_prec p_dm=0;
        real_prec p_dm2=0;
        real_prec p_dm3=0;
        real_prec power_hm_s=0;
        real_prec gama=0;
        for(ULONG i=initial_mode; i< power_cross.size();++i)
          {
            power_hm+=power_cross[i]; // *** here it must be nmodes*(<power>_av)= nmodes*(power/nmodes)=power. That's why I do not need nmodes
#ifndef _TNG_GAL_
            power_hm_s+=power_cross_s[i]; // *** here it must be nmodes*(<power>_av)= nmodes*(power/nmodes)=power. That's why I do not need nmodes
#endif
            p_dm+=power_dmat[i];
#ifndef _TNG_GAL_
            gama+=Gamma_num[i];
#endif
            if(this->kvector_data[i]<kmax_b)
            {
                power_hm2+=power_cross[i]; // *** here it must be nmodes*(<power>_av)= nmodes*(power/nmodes)=power. That's why I do not need nmodes
                p_dm2+=power_dmat[i];
             }
            if(this->kvector_data[i]<kmax_c)
            {
                power_hm3+=power_cross[i]; // *** here it must be nmodes*(<power>_av)= nmodes*(power/nmodes)=power. That's why I do not need nmodes
                p_dm3+=power_dmat[i];
             }

        }
        real_prec hb=(vol)*(power_hm/p_dm)/(vol/this->params._NGRID());
        real_prec hb2=(vol)*(power_hm2/p_dm2)/(vol/this->params._NGRID());
        real_prec hb3=(vol)*(power_hm3/p_dm3)/(vol/this->params._NGRID());
#ifndef _TNG_GAL_
        real_prec hbs=(vol)*(power_hm_s/p_dm)/(vol/this->params._NGRID());
        gama= (vol)*(gama/p_dm)/(vol/this->params._NGRID());
#endif
        tracer_cat[itr].bias=hb;
        tracer_cat[itr].bias2=hb2;
        tracer_cat[itr].bias3=hb3;
#ifndef _TNG_GAL_
        tracer_cat[itr].bias_rs=hbs;
        tracer_cat[itr].rs_factor=gama;
#endif
        lss_bias_halo+=hb;
   }
   lss_bias_halo/=static_cast<real_prec>(tracer_cat.size());
   So.message_screen("\tMean large-scale bias from individual bias =", lss_bias_halo);





#ifdef _TNG_GAL_

   vector<real_prec>baux(tracer_cat.size(),0);
   vector<real_prec>xaux(tracer_cat.size(),0);
   vector<real_prec>yaux(tracer_cat.size(),0);
   vector<real_prec>zaux(tracer_cat.size(),0);
    for(ULONG i=0;i<xaux.size(); ++i)
    {
        baux[i]=tracer_cat[i].bias;
        xaux[i]=tracer_cat[i].coord1;
        yaux[i]=tracer_cat[i].coord2;
        zaux[i]=tracer_cat[i].coord3;
    }
    string file_bias=this->params._Output_directory()+"Bias_gal1";
    this->File.write_array(file_bias, baux);

    vector<real_prec>bfaux(this->params._NGRID(),0);

    string file_bias_f=this->params._Output_directory()+"Bias_gal1_field";
    getDensity_CIC(this->params._Nft(),this->params._Nft(),this->params._Nft(),this->params._Lbox(),this->params._Lbox(),this->params._Lbox(),this->params._d_delta_x(),this->params._d_delta_x(),this->params._d_delta_x(),0,0,0,xaux,yaux,zaux,baux,bfaux,true);
    this->File.write_array(file_bias_f, bfaux);



    file_bias=this->params._Output_directory()+"Bias_gal2";
    for(ULONG i=0;i<baux.size(); ++i)
       baux[i]=tracer_cat[i].bias2;
     this->File.write_array(file_bias, baux);
    file_bias_f=this->params._Output_directory()+"Bias_gal2_field";
    getDensity_CIC(this->params._Nft(),this->params._Nft(),this->params._Nft(),this->params._Lbox(),this->params._Lbox(),this->params._Lbox(),this->params._d_delta_x(),this->params._d_delta_x(),this->params._d_delta_x(),0,0,0,xaux,yaux,zaux,baux,bfaux,true);
    this->File.write_array(file_bias_f, bfaux);



    file_bias=this->params._Output_directory()+"Bias_gal3";
    for(ULONG i=0;i<baux.size(); ++i)
       baux[i]=tracer_cat[i].bias3;
     this->File.write_array(file_bias, baux);
    file_bias_f=this->params._Output_directory()+"Bias_gal3_field";
    getDensity_CIC(this->params._Nft(),this->params._Nft(),this->params._Nft(),this->params._Lbox(),this->params._Lbox(),this->params._Lbox(),this->params._d_delta_x(),this->params._d_delta_x(),this->params._d_delta_x(),0,0,0,xaux,yaux,zaux,baux,bfaux,true);
    this->File.write_array(file_bias_f, bfaux);

#endif




   So.DONE();

 }


 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************


 //#define paired
// #define parallel_grf
#define white_noise
 void PowerSpectrumF::get_GaussianRandomField(){

#ifdef _USE_OMP_
   omp_set_num_threads(_NTHREADS_);
#endif

   ULONG ir=0;
   int ndel=1;
   real_prec Lside=this->params._Lbox();
   real_prec kmax=this->params._Kmax_FA();
   int Nft=static_cast<int>(this->params._Nft());
   int Nft_LR=Nft;
   ULONG Nft_HR=this->params._Nft_HR();
   ULONG NTT=Nft*Nft*(Nft/2+1);
   ULONG Ngrid_LR=Nft_LR*Nft_LR*Nft_LR;
   ULONG Ngrid_HR=Nft_HR*Nft_HR*Nft_HR;
   ULONG Ngrid=this->params._NGRID();

   if(true==this->params._use_low_pass_filter())
     {
       this->params.set_Nft(this->params._Nft_HR());// assign Nft_HR to Nft if we want to apply the low-pass filter
       Nft=this->params._Nft();
       Ngrid=this->params.d_NGRID();
       NTT=Nft*Nft*(Nft/2+1);
     }

   // ******************************************************************************
   // Computation of cosmological growth
   real_prec g1=this->cosmology.growth_factor(this->params._Initial_Redshift_DELTA(), (void *)&this->params.s_cosmo_pars);
   real_prec g2=this->cosmology.growth_factor(this->params._Initial_Redshift_TH_power_file(), (void *)&this->params.s_cosmo_pars);
   real_prec ic_factor=1.;
   if(this->params._Normalize_IC_to_initial_redshift()==true)
     ic_factor= pow(g1/g2,2);
#ifdef _ABACUS_
   real_prec abacus_factor=47.304805056;
   ic_factor=1./(pow(abacus_factor,2));
#endif

   So.message_screen("Growth at redshift of theoretical power", g1);
   So.message_screen("Growth at redshift of initial conditions", g2);
   So.message_screen("IC Factor", ic_factor);

   // ******************************************************************************
   real_prec norm=(Ngrid*Ngrid) / pow(Lside,3);  // Normalization of power spectrum. Multiply by this factor to un-normalize the theoretical power
   vector<real_prec>prop;
   string power_file=this->params._dir()+this->params._ic_power_file();
   ULONG nlines_p=this->File.read_file(power_file,prop,8);
   ULONG ncols=(static_cast<ULONG>(prop.size()/nlines_p));
   vector<double>kv(nlines_p,0);
   vector<double>pv(nlines_p,0);
   for(ULONG i=0;i<nlines_p;++i)
     {
       kv[i]=static_cast<double>(prop[ncols*i]);
#ifdef _USE_IC_INPUT_POWER_DELTA_
       pv[i]=static_cast<double>(prop[1+ncols*i])*(norm*ic_factor)*(2.*M_PI*M_PI)/pow(kv[i],3); //con factor dejo el P(k) a z=z_initial_simulation
#else
#ifdef _correct_shape_theoretica_power_
       pv[i]=static_cast<double>(prop[1+ncols*i])*(norm*ic_factor)/(1.0+0.05*kv[i]*kv[i]); //con factor dejo el P(k) a z=z_initial_simulation

#else
       pv[i]=static_cast<double>(prop[1+ncols*i])*(norm*ic_factor); //con factor dejo el P(k) a z=z_initial_simulation
#endif
#endif
     }
   So.DONE();
   prop.clear();prop.shrink_to_fit();

   // ******************************************************************************
   gsl_interp_accel *acc = gsl_interp_accel_alloc();
   gsl_spline *spline = gsl_spline_alloc(gsl_interp_linear,kv.size());
   gsl_spline_init(spline,&kv[0],&pv[0],pv.size());
   real_prec deltak=this->params._d_DeltaK_data();
   real_prec ideltak=1.0/static_cast<double>(deltak);
   // ******************************************************************************

   vector<real_prec> coords(Nft,0);// Coordinates of wavevectors in a regular grid
   for(ULONG i=0;i<Nft ;++i)
     coords[i]=deltak*(i<=Nft/2  ? static_cast<real_prec>(i): -static_cast<real_prec>(Nft-i));

   vector<real_prec> mean_power(Nft/2/ndel,0);// Mean power to be updated

   vector<real_prec>IC_field_grf(Ngrid,0);


   for(ir=0;ir<this->params._Number_of_GRF();++ir)
     {
       So.message_screen("Realization ", ir);

       complex_prec *IC_FOURIER_GRF= (complex_prec *)fftw_malloc(2*NTT*sizeof(real_prec));
#ifdef paired
       complex_prec *IC_FOURIER_GRF_PAIRED= (complex_prec *)fftw_malloc(2*NTT*sizeof(real_prec));
       complex_prec *IC_FOURIER_GRF_PAIRED_2= (complex_prec *)fftw_malloc(2*NTT*sizeof(real_prec));
       complex_prec *IC_FOURIER_GRF_PAIRED_4= (complex_prec *)fftw_malloc(2*NTT*sizeof(real_prec));
#endif
       complex_prec *IC_FOURIER_MIXED;
       complex_prec *IC_FOURIER_FA;

       vector<ULONG> nmodes(Nft/2/ndel,0);
       vector<real_prec> IC_GRF(Nft/2/ndel,0);
       vector<real_prec> IC_TH(Nft/2/ndel,0);
#ifdef paired
       vector<real_prec> IC_GRF_PAIRED(Nft/2/ndel,0);
       vector<real_prec> IC_GRF_PAIRED_2(Nft/2/ndel,0);
       vector<real_prec> IC_GRF_PAIRED_4(Nft/2/ndel,0);
#endif
       vector<real_prec> IC_MIXED;
       vector<real_prec> IC_FA;
       vector<real_prec> IC_GRF_lr;
       vector<real_prec> IC_MIXED_lr;
       vector<real_prec> IC_FA_lr;

       if(true==this->params._use_low_pass_filter())
     {
       IC_GRF_lr.resize(Nft_LR/2/ndel,0);
       if(true==this->params._Generate_FA())
         {
           IC_MIXED_lr.resize(Nft_LR/2/ndel,0);
           IC_FA_lr.resize(Nft_LR/2/ndel,0);
         }
     }

       if(true==this->params._Generate_FA())
     {
       IC_FA.resize(Nft/2/ndel,0);
       IC_MIXED.resize(Nft/2/ndel,0);
     }




       //************************************ parallel stuff****************
       // This is the right way to implement parallelization with random number generators //
#ifdef parallel_grf
       gsl_rng **gBaseRand = new gsl_rng *[_NTHREADS_];
       for (int b = 0; b < _NTHREADS_; b++)
     {
       gBaseRand[b] = gsl_rng_alloc(gsl_rng_mt19937);
       gsl_rng_set(gBaseRand[b], b * 101*(ir+1));
     }
#else
       gsl_rng * gBaseRand;
       const gsl_rng_type * rng_t;
#endif
       gsl_rng_env_setup();

       if(true==this->params._Generate_FA())
     {
       IC_FOURIER_MIXED= (complex_prec *)fftw_malloc(2*NTT*sizeof(real_prec));
       IC_FOURIER_FA= (complex_prec *)fftw_malloc(2*NTT*sizeof(real_prec));
       So.message_screen("Going for fixed amplitude");
#ifdef parallel_grf
#pragma omp parallel
       {
         int jthread=omp_get_thread_num();
#pragma omp for nowait
#else
         gsl_rng_default_seed= 5658*(ir+1);
         rng_t = gsl_rng_mt19937;
         gBaseRand = gsl_rng_alloc (rng_t);
#endif

         for(ULONG i=0;i<Nft;++i)
           {
         for(ULONG j=0;j< Nft;++j)
           {
             for(ULONG k=0;k<Nft/2+1;++k)
               {
             ULONG lp=index_3d(i,j,k,Nft,Nft/2+1);                                      // 3D C-like index
             real_prec kmod=sqrt(pow(coords[i],2)+pow(coords[j],2)+pow(coords[k],2)); // k=|k|= Magnitude of wave-vector
             ULONG ik=static_cast<ULONG>(floor(kmod/deltak));                                               // Bin in k
             real_prec Power_th = (kmod<kv[0] ? 0 : gsl_spline_eval(spline,kmod, acc));  // Theoretial Power interpolated at k
#ifdef parallel_grf
             real_prec phi_ic = 2.*M_PI*gsl_rng_uniform(gBaseRand[jthread]);                     // GR: Random phases. Add pi to get the inverted-phase pair
             real_prec Amp_ic = gsl_ran_rayleigh(gBaseRand[jthread],sqrt(0.5*Power_th));         // GR: Random Amplitude->Reyleigh distribution
#else
             real_prec phi_ic = 2.*M_PI*gsl_rng_uniform(gBaseRand);                     // GR: Random phases. Add pi to get the inverted-phase pair
             real_prec Amp_ic = gsl_ran_rayleigh(gBaseRand,sqrt(0.5*Power_th));         // GR: Random Amplitude->Reyleigh distribution
#endif
             real_prec cphi = cos(phi_ic);                                              // Cosinos of phase
             real_prec sphi = sin(phi_ic);                                              // Sin of phase
             IC_FOURIER_GRF[lp][REAL] = Amp_ic*cphi;                             // Real part of GR field
             IC_FOURIER_GRF[lp][IMAG] = Amp_ic*sphi;                             // Imag part of Mixed field
#ifdef paired
             real_prec cphi_paired = cos(phi_ic+M_PI);                                              // Cosinos of phase
             real_prec sphi_paired = sin(phi_ic+M_PI);                                              // Sin of phase
             IC_FOURIER_GRF_PAIRED[lp][REAL] = Amp_ic*cphi_paired;                             // Real part of GR field
             IC_FOURIER_GRF_PAIRED[lp][IMAG] = Amp_ic*sphi_paired;                             // Imag part of Mixed field
#endif
             real_prec Amp_faf = sqrt(Power_th);                                        // FA: Amplitude fixed to the power at k
             real_prec Amp_ic_final = kmod<=kmax ? Amp_faf: Amp_ic;                    // Final amplitude: below kmax, let it FA: above, let it GR
             IC_FOURIER_MIXED[lp][REAL] = Amp_ic_final*cphi;                                // Real part of Mixed field
             IC_FOURIER_MIXED[lp][IMAG] = Amp_ic_final*sphi;                                // Imag part of Mixed field
             IC_FOURIER_FA[lp][REAL] = Amp_faf*cphi;                                   // Real part of FA field
             IC_FOURIER_FA[lp][IMAG] = Amp_faf*sphi;                                   // Imag part of FA field
             // Do shell average to measure power of the three fields
             if(ik<Nft/2/ndel)
               {
#ifdef parallel_grf
#pragma omp atomic
#endif
                 nmodes[ik]++;    // Number of modes in k-shells
#ifdef parallel_grf
#pragma omp atomic
#endif
                 IC_MIXED[ik]+= pow(Amp_ic_final,2);  // Mixed
#ifdef parallel_grf
#pragma omp atomic
#endif
                 IC_FA[ik]+= pow(Amp_faf,2);      // FA
#ifdef parallel_grf
#pragma omp atomic
#endif
                 IC_TH[ik]+= pow(sqrt(Power_th),2); //Theoretical power evaluated at the Fourier mesh
#ifdef parallel_grf
#pragma omp atomic
#endif
                 IC_GRF[ik]+= pow(Amp_ic,2);  // GRF
               }
               }
           }
           }
#ifdef parallel_grf
       } // closes parallel region
#endif

     }// closes if

       else if (false==this->params._Generate_FA()) // this is only gaussian
     {

#ifdef parallel_grf
#pragma omp parallel
       {
         int  jthread=omp_get_thread_num();
#pragma omp for nowait
#else
             gsl_rng_default_seed= 5658*(ir+1587);
         rng_t = gsl_rng_mt19937;
         gBaseRand = gsl_rng_alloc (rng_t);
#endif

#ifdef white_noise
         // get a white noise
         So.message_screen("Getting white noise");
         for(ULONG i=0;i< IC_field_grf.size();++i)
           IC_field_grf[i]=gsl_rng_uniform(gBaseRand);
         // Get mean of WN
             real_prec meanWN=get_mean(IC_field_grf);
         // Ensure that WN has zero mean
         for(ULONG i=0;i< IC_field_grf.size();++i)
           IC_field_grf[i]-=meanWN;
         meanWN=0;
         for(ULONG i=0;i< IC_field_grf.size();++i)
           meanWN+=IC_field_grf[i];
         meanWN/=static_cast<real_prec>(IC_field_grf.size());
         this->So.message_screen("Mean WN =",meanWN);
         //Compute variance of the field sigma²
         real_prec sigmaWN=0;
         for(ULONG i=0;i< IC_field_grf.size();++i)
           sigmaWN+=(IC_field_grf[i]-meanWN)*(IC_field_grf[i]-meanWN);
         sigmaWN/=static_cast<real_prec>(IC_field_grf.size()-1);
         this->So.message_screen("Sigma² WN =",sigmaWN);

             // Nrmalize field to get sigma² = 1
         real_prec factor=static_cast<double>(sqrt(sigmaWN));
         for(ULONG i=0;i< IC_field_grf.size();++i)
           IC_field_grf[i]/=factor;

             for(int ui=0;ui<2;ui++)
           {
         meanWN=0;
         for(ULONG i=0;i< IC_field_grf.size();++i)
           meanWN+=IC_field_grf[i];
         meanWN/=static_cast<real_prec>(IC_field_grf.size());
         for(ULONG i=0;i< IC_field_grf.size();++i)
           IC_field_grf[i]-=meanWN;
         sigmaWN=0;
         for(ULONG i=0;i< IC_field_grf.size();++i)
           sigmaWN+=(IC_field_grf[i]-meanWN)*(IC_field_grf[i]-meanWN);
         sigmaWN/=static_cast<real_prec>(IC_field_grf.size()-1);
         factor=static_cast<double>(sqrt(sigmaWN));
         for(ULONG i=0;i< IC_field_grf.size();++i)
           IC_field_grf[i]/=factor;
         sigmaWN=0;
         for(ULONG i=0;i< IC_field_grf.size();++i)
           sigmaWN+=(IC_field_grf[i]-meanWN)*(IC_field_grf[i]-meanWN);
         sigmaWN/=static_cast<real_prec>(IC_field_grf.size()-1);
           }
         this->So.message_screen("New Sigma² WN =",sigmaWN);


         do_fftw_r2c(Nft ,IC_field_grf,IC_FOURIER_GRF);

         real_prec factorN=static_cast<real_prec>(Ngrid);
#endif


         So.message_screen("Going for GRF");
         // Loop over half of the Fourier box
             for(int i=0; i < Nft;++i)
               {
                 int i_m= (i <= Nft/2 ? i : Nft-i);
                 real_prec i_deltak_x =  static_cast<real_prec>(i_m *i_m) *this->params._d_deltak_x() * this->params._d_deltak_x();
                 for(int j=0; j < Nft; ++j)
           {
                     int j_m= (j <= Nft/2 ? j : Nft-j);
                     real_prec i_deltak_y = static_cast<real_prec>(j_m * j_m) * this->params._d_deltak_y() * this->params._d_deltak_y();
                     for(int k=0; k<=Nft/2 ;++k)
               {
                         real_prec i_deltak_z = static_cast<real_prec>(k * k) * this->params._d_deltak_z() * this->params._d_deltak_z();
             real_prec kmod = sqrt(i_deltak_x+i_deltak_y+i_deltak_z); // k=|k|= Magnitude of wave-vector
                         real_prec Power_th = 0;
                         if(kmod>=kv[0] && kmod<kv[kv.size()-1])
                           Power_th = gsl_spline_eval(spline,kmod, acc); // Theoretial Power interpolated at k

#ifndef white_noise
#ifdef parallel_grf
             real_prec Amp_ic = gsl_ran_rayleigh(gBaseRand[jthread],sqrt(0.5*Power_th));
                         real_prec phi_ic = 2.*M_PI*gsl_rng_uniform(gBaseRand[jthread]);
#else
             real_prec Amp_ic = static_cast<real_prec>(gsl_ran_rayleigh(gBaseRand,sqrt(0.5*Power_th)));
             real_prec phi_ic = 2.*M_PI*gsl_rng_uniform(gBaseRand);
#endif

             IC_FOURIER_GRF[lp][REAL] = Amp_ic*cos(phi_ic);
                         IC_FOURIER_GRF[lp][IMAG] = -Amp_ic*sin(phi_ic);
#else
             real_prec Amp_ic = sqrt(Power_th/factorN);
             ULONG lp = index_3d(i,j,k,Nft,Nft/2+1);
                         IC_FOURIER_GRF[lp][REAL] *= Amp_ic;
                         IC_FOURIER_GRF[lp][IMAG] *= Amp_ic;
#endif


                         int ik = static_cast<int>(floor((kmod-this->params._d_kmin())*ideltak));

                         if(ik<nmodes.size())
               {
#ifdef parallel_grf
#pragma omp atomic
#endif
                 nmodes[ik]++;    // Number of modes in k-shells
#ifdef parallel_grf
#pragma omp atomic
#endif
                 IC_TH[ik]+=Power_th; //Theoretical power evaluated at the Fourier mesh
#ifdef parallel_grf
#pragma omp atomic
#endif
                             IC_GRF[ik]+= IC_FOURIER_GRF[lp][REAL]*IC_FOURIER_GRF[lp][REAL]+ IC_FOURIER_GRF[lp][IMAG]*IC_FOURIER_GRF[lp][IMAG];
                           }


               }
           }
           }
#ifdef parallel_grf
       } // closes parallel region
#endif
     }//closes else
       So.DONE();

       So.message_screen("Getting power");

       if(true==this->params._Generate_FA())
     {
       for(ULONG i=0;i<IC_MIXED.size();++i)
         if(nmodes[i]>0)
           IC_MIXED[i]/=static_cast<real_prec>(nmodes[i]*norm);


       for(ULONG i=0;i<IC_FA.size();++i)
         if(nmodes[i]>0)
           IC_FA[i]/=static_cast<real_prec>(nmodes[i]*norm);
     }


       else if(false==this->params._Generate_FA())
     {

       for(ULONG i=0;i<IC_TH.size();++i)
         if(nmodes[i]>0)
           IC_TH[i]/=static_cast<real_prec>(nmodes[i]*norm);

       for(ULONG i=0;i<IC_GRF.size();++i)
         if(nmodes[i]>0)
               IC_GRF[i]/=(static_cast<real_prec>(nmodes[i])*norm);

     }
       So.DONE();

       // Vectors to allocate overdensities

       vector<real_prec>IC_field_fa;
       vector<real_prec>IC_field_mixed;

       do_fftw_c2r(Nft ,IC_FOURIER_GRF,IC_field_grf);
       fftw_free(IC_FOURIER_GRF);

       if(true==this->params._Generate_FA())
     {
       IC_field_fa.resize(Ngrid,0);
       do_fftw_c2r(Nft ,IC_FOURIER_FA,IC_field_fa);
       IC_field_mixed.resize(Ngrid,0);
       do_fftw_c2r(Nft ,IC_FOURIER_MIXED,IC_field_mixed);
       fftw_free(IC_FOURIER_MIXED);
       fftw_free(IC_FOURIER_FA);
     }

       So.DONE();

       vector<real_prec>IC_field_grf_lr(Ngrid_LR,0);
       vector<real_prec>IC_field_grf_paired_lr(Ngrid_LR,0);
       vector<real_prec>IC_field_fa_lr;
       vector<real_prec>IC_field_mixed_lr;

       if(true==this->params._use_low_pass_filter())
     {
       So.message_screen("Applying low pass filter: ");

       real_prec mean_HR=static_cast<real_prec>(Ngrid_HR)/pow(params._Lbox(),3);
       for(ULONG i=0; i<IC_field_grf.size();++i)
         IC_field_grf[i]=mean_HR*(1.0+IC_field_grf[i]);

           low_pass_filter(Nft_HR,Nft_LR,1,false, IC_field_grf,IC_field_grf_lr, params._Lbox());
       get_overdens(IC_field_grf_lr,IC_field_grf_lr);

       this->File.write_array(this->params._Output_directory()+"IC_GRF_lpass_realization"+to_string(ir)+"_Nres"+to_string(Nft_LR), IC_field_grf_lr);
       this->File.write_array(this->params._Output_directory()+"IC_GRF_lpass_paired_realization"+to_string(ir)+"_Nres"+to_string(Nft_LR), IC_field_grf_paired_lr);
       this->params.set_input_type("delta_grid");
       this->params.set_Nft(Nft_LR);
       this->params.set_NGRID(Ngrid_LR);
       this->params.set_SN_correction(false);
       this->params.set_MAS_correction(false);
           this->compute_power_spectrum_grid(IC_field_grf_lr, false);
       for(ULONG i=0;i<IC_GRF_lr.size();++i)
         IC_GRF_lr[i]=this->pk0[i];

       if(true==this->params._Generate_FA())
         {
           IC_field_fa_lr.resize(Ngrid_LR,0);
           IC_field_mixed_lr.resize(Ngrid_LR,0);
               low_pass_filter(Nft_HR,Nft_LR,1,false, IC_field_fa,IC_field_fa_lr, params._Lbox());
           this->File.write_array(this->params._Output_directory()+"IC_FA_realization"+to_string(ir)+"_Nres"+to_string(Nft_LR), IC_field_fa_lr) ;
               low_pass_filter(Nft_HR,Nft_LR,1,false, IC_field_mixed,IC_field_mixed_lr, params._Lbox());
           this->File.write_array(this->params._Output_directory()+"IC_mixed_realization"+to_string(ir)+"_Nres"+to_string(Nft_LR), IC_field_mixed_lr);
         }
       So.DONE();
     }
       else
     {
       this->File.write_array(this->params._Output_directory()+"IC_GRF_realization"+to_string(ir)+"_Nres"+to_string(Nft_LR), IC_field_grf);
       if(true==this->params._Generate_FA())
         {
           this->File.write_array(this->params._Output_directory()+"IC_FA_realization"+to_string(ir)+"_Nres"+to_string(Nft_LR), IC_field_fa) ;
           this->File.write_array(this->params._Output_directory()+"IC_mixed_realization"+to_string(ir)+"_Nres"+to_string(Nft_LR), IC_field_mixed);
         }
     }



#ifdef _USE_GNUPLOT_
       vector<pair<real_prec, real_prec> > xy_pts_fa;
       vector<pair<real_prec, real_prec> > xy_pts_mixed;
       vector<pair<real_prec, real_prec> > xy_pts_grf;
       vector<pair<real_prec, real_prec> > xy_pts_th;
       vector<pair<real_prec, real_prec> > xy_pts_grf_lr;
       vector<pair<real_prec, real_prec> > xy_pts_mean_power;

       for(ULONG i=0;i<IC_GRF.size();++i) // Update mean power
          mean_power[i]+=(IC_GRF[i]-mean_power[i])/static_cast<real_prec>(ir+1);

       for(ULONG i=1;i<mean_power.size();++i)
          xy_pts_mean_power.push_back(std::make_pair(deltak*(i+0.5), (mean_power[i])));

       for(ULONG i=1;i<IC_GRF.size();++i)
         xy_pts_grf.push_back(std::make_pair(deltak*(i+0.5), (IC_GRF[i])));

      if(true==this->params._use_low_pass_filter())
         for(ULONG i=1;i<IC_GRF_lr.size();++i)
           xy_pts_grf_lr.push_back(std::make_pair(deltak*(i+0.5), (IC_GRF_lr[i])));

       for(ULONG i=1;i<IC_TH.size();++i)
     xy_pts_th.push_back(std::make_pair(deltak*(i+0.5), (IC_TH[i])));

       if(true==this->params._Generate_FA())
     {
       for(ULONG i=1;i< IC_FA.size();++i)
         xy_pts_fa.push_back(std::make_pair(deltak*(i+0.5), IC_FA[i]));

       for(ULONG i=1;i<IC_MIXED.size();++i)
         xy_pts_mixed.push_back(std::make_pair(deltak*(i+0.5), (IC_MIXED[i])));
     }


       this->gp_pdf<<"set size 1,1\n";
       this->gp_pdf<<"set origin 0., 0.\n";
       this->gp_pdf<<"set grid\n";
       this->gp_pdf << "set log x \n";
       this->gp_pdf << "set log y \n";
       this->gp_pdf << "set ylabel 'Power Spectrum P(k)'\n";
       this->gp_pdf << "set xlabel 'k [Mpc/h]'\n";
       if(ir==0)
     {
       if(true==this->params._Generate_FA())
         {
#ifdef _USE_IC_INPUT_POWER_DELTA_
           this->gp_pdf << "plot[0.003:3][0.001:50]" << this->gp_pdf.file1d(xy_pts_grf) << "w l lw 1 lt 11  title 'GRF', "<<this->gp_pdf.file1d(xy_pts_fa)<<"w l lw 3 lt 2 title 'FA',"<<this->gp_pdf.file1d(xy_pts_mixed)<<"w l lw 3 lt 4 title 'MIXED', "<<gp_pdf.file1d(xy_pts_th)<<" w l lw 1 title 'CAMB_g','"<<power_file<<"' u 1:($2*(2.0*acos(-1.0)*acos(-1.0))/($1*$1*$1)) w l lt 2 ,"<<gp_pdf.file1d(xy_pts_grf_lr)<<" w l lw 1 title 'GRF_lr'"<<endl;
#else
#ifdef _ABACUS_
               this->gp_pdf<<"factor=(1./47.304805056)**2 \n";
#elif defined _UNITSIM_
               this->gp_pdf<<"factor=0.000158091416709513\n";
#endif
               this->gp_pdf<<"plot[0.003:3][0.001:50]" << this->gp_pdf.file1d(xy_pts_grf) << "w l lw 1 lt 11  title 'GRF', "<<this->gp_pdf.file1d(xy_pts_fa)<<"w l lw 3 lt 2 title 'FA',"<<this->gp_pdf.file1d(xy_pts_mixed)<<"w l lw 3 lt 4 title 'MIXED', "<<gp_pdf.file1d(xy_pts_th)<<" w l lw 1 title 'CAMB_g','"<<power_file<<"' u 1:($2*factor) w l lt 2 ,"<<gp_pdf.file1d(xy_pts_grf_lr)<<" w l lw 1 title 'GRF_lr'"<<endl;
#endif
         }
       else if (false==this->params._Generate_FA())
         {
#ifdef _USE_IC_INPUT_POWER_DELTA_
           this->gp_pdf << "plot[0.003:3][0.001:50]" << this->gp_pdf.file1d(xy_pts_grf) << "w l lw 1 lt 11  title 'GRF', "<<gp_pdf.file1d(xy_pts_th)<<"w l lw 3 title 'CAMB_g', '"<<power_file<<"' u 1:($2*(2.0*acos(-1.0)*acos(-1.0))/($1*$1*$1)) w l lt 2 ,"<<gp_pdf.file1d(xy_pts_grf_lr)<<" w l lw 4 title 'GRF_lr'"<<endl;
#else
#ifdef _ABACUS_
               this->gp_pdf<<"factor=(1./47.304805056)**2 \n";
#elif defined _UNITSIM_
               this->gp_pdf<<"factor=0.000158091416709513\n";
#endif
           this->gp_pdf << "plot[0.003:3][0.001:50]" << this->gp_pdf.file1d(xy_pts_grf) << "w l lw 1 lt 11  title 'GRF', "<<gp_pdf.file1d(xy_pts_th)<<"w l lw 3 title 'CAMB_g', '"<<power_file<<"'  u 1:($2*factor) w l lt 2 ,"<<gp_pdf.file1d(xy_pts_grf_lr)<<" w l lw 4 title 'GRF_lr'"<<endl;
#endif
         }
     }
       else if(ir>0)
     {
       if(true==this->params._Generate_FA())
         this->gp_pdf << "replot" << this->gp_pdf.file1d(xy_pts_grf) << "w l lw 1 lt 11 notitle , "<<this->gp_pdf.file1d(xy_pts_fa)<<"w l lw 1 lt 2 notitle ,"<<this->gp_pdf.file1d(xy_pts_mixed)<<"w l lw 3 lt 4 notitle ,"<<gp_pdf.file1d(xy_pts_grf_lr)<<" w l lw 1 notitle"<<endl;
       else
             this->gp_pdf << "replot" << this->gp_pdf.file1d(xy_pts_grf) << "w l lw 1 notitle ,"<<gp_pdf.file1d(xy_pts_grf_lr)<<" w l lw 1 notitle"<<endl;
//           this->gp_pdf << "replot" << this->gp_pdf.file1d(xy_pts_grf) << "w l lw 1 notitle ,"<<gp_pdf.file1d(xy_pts_grf_lr)<<" w l lw 1 notitle, "<<gp_pdf.file1d(xy_pts_mean_power)<<" w l lw 3 lt 3 notitle "<<endl;
      // this->gp_pdf << "replot" <<gp_pdf.file1d(xy_pts_mean_power)<<" w l lw 3 lt 3 notitle "<<endl;
     }
#endif

        if(ir==0)
        {
       ofstream atea; atea.open(this->params._Output_directory()+"mean_power_th.txt");
       atea.precision(6);
       atea.setf(ios::showpoint);
       atea.setf(ios::scientific);
       for(int i=1;i<IC_TH.size();++i)
        atea<<deltak*(i+0.5)<<"  "<<IC_TH[i]<<endl;
       atea.close();
        }
       ofstream btea; btea.open(this->params._Output_directory()+"power_grf_real"+to_string(ir)+".txt");
       btea.precision(6);
       btea.setf(ios::showpoint);
       btea.setf(ios::scientific);

       for(int i=1;i<IC_GRF.size();++i)
        btea<<deltak*(i+0.5)<<"\t"<<IC_GRF[i]<<"\t"<<nmodes[i]<<endl;
       btea.close();

       }// closes loop over ir


   ofstream tea; tea.open(this->params._Output_directory()+"mean_power.txt");
   for(ULONG i=0;i<mean_power.size();++i)
    tea<<deltak*(i+0.5)<<"  "<<mean_power[i]<<endl;
   tea.close();

   gsl_spline_free(spline);
   gsl_interp_accel_free(acc);


   So.DONE();
 }



   // ****************************************************************************************************************************************************************************************************************
   // ****************************************************************************************************************************************************************************************************************
   // ****************************************************************************************************************************************************************************************************************
   // ****************************************************************************************************************************************************************************************************************
   // ****************************************************************************************************************************************************************************************************************
   // ****************************************************************************************************************************************************************************************************************
   // ****************************************************************************************************************************************************************************************************************
 pair<real_prec, real_prec> PowerSpectrumF::get_lss_cross_bias(vector<real_prec>&p1, vector<real_prec>&p2,  vector<real_prec>&kv,  vector<int>&nmodes, int init_mode, real_prec kmax)
 {
   real_prec lss_bias_k=0;
   real_prec lss_bias=0;
   int ik=init_mode;
   while(kv[ik]<kmax)
     {
       lss_bias+=(p1[ik]/p2[ik])*static_cast<real_prec>(nmodes[ik]);
       lss_bias_k+=static_cast<real_prec>(nmodes[ik]);
       ++ik;
     }
   lss_bias/=lss_bias_k;
   real_prec var_lss_bias=0;
   ik=init_mode;
   while(kv[ik]<kmax)
     {
       var_lss_bias+=pow(p1[ik]/p2[ik]-lss_bias,2)*static_cast<real_prec>(nmodes[ik]);
       ++ik;
     }
   var_lss_bias=sqrt(var_lss_bias/lss_bias_k);
   return std::make_pair(lss_bias, var_lss_bias);
 }

  // ****************************************************************************************************************************************************************************************************************
   // ****************************************************************************************************************************************************************************************************************
   // ****************************************************************************************************************************************************************************************************************
 pair<real_prec, real_prec> PowerSpectrumF::get_lss_bias(vector<real_prec>&p1, vector<real_prec>&p2,  vector<real_prec>&kv,  vector<int>&nmodes, int init_mode, real_prec kmax)
 {
     // *****************************************************************************************
     // *****************************************************************************************
     // If the power spectra involved come from a Gaussian IC, we need to use the error bars
     // from the Gaussian approximation on large scales, and compute <bias>=sum (b_k /sigma_b_k²) and sigma² = sum(1/sigma_b_k²)
     // where sigma_b_k is the error on the bias b=sqrt(Ph/Pdm), given as
     // sigma_b_k² = (1/4)*(b_k)³*(sigma_k_h²/P_h² + sigma_k_dm²/P_dm² ) (added in quadrature)
     // where sigma_k² = P² * (2/N_k) (neglecting shot noise).
     // This yields <b>=sum (N_k /b_k²) / sum (N_k /b_k³) and
     // sigma_b_k² = b_k³/N_k =  1/sum(N_k/b_k³)
     // where N_k is the number of modes in each k-bin
     // *****************************************************************************************
     // If we use Fixed amplitude fields, the average bias is computed as a simple mean and
     // its errors follows from the standard deviation
     // *****************************************************************************************
   real_prec lss_bias_k=0;
   real_prec lss_bias=0;
   int ik=init_mode;
   while(kv[ik]<kmax)
     {
       lss_bias+=sqrt(p1[ik]/p2[ik])*nmodes[ik];
       lss_bias_k+=static_cast<real_prec>(nmodes[ik]);
       ++ik;
     }
   lss_bias/=lss_bias_k;
   real_prec var_lss_bias=0;
   ik=init_mode;
   while(kv[ik]<kmax)
     {
       var_lss_bias+=pow(sqrt(p1[ik]/p2[ik])-lss_bias,2)*nmodes[ik];
       ++ik;
     }
   var_lss_bias=sqrt(var_lss_bias/lss_bias_k);
  return std::make_pair(lss_bias, var_lss_bias);
  
 }
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 void PowerSpectrumF::GetSuperClusters(){

    int NTHREADS = 1;
#ifdef _USE_OMP_
    NTHREADS=_NTHREADS_;
#endif


   vector<real_prec> DM_DEN_FIELD( this->params._NGRID(),0);
   this->File.read_array(this->params._Input_Directory_X()+this->params._Name_Catalog_X(),DM_DEN_FIELD);
   this->params.set_input_type("density_grid");
   this->set_output_filenames();
   this->So.message_screen("Getting object-to-object bias");
   Catalog cat(this->params);
   cat.read_catalog(this->params._Input_dir_cat()+this->params._file_catalogue(),0);
    this->set_params(cat.params); // params has been updated inside the catalog class.

   kvector_data.clear();
   kvector_data.shrink_to_fit();
   for(int i=0;i<this->params._d_Nnp_data();i++)
    kvector_data.push_back(this->params._d_kmin()+this->params._d_DeltaK_data()*(i+0.5));
   
   this->object_by_object_bias(cat.Halo,DM_DEN_FIELD);
   this->So.message_screen("\tMin Bias  =", cat.get_min("_BIAS_"));
   this->So.message_screen("\tMax Bias  =", cat.get_max("_BIAS_"));
   

   //******************************************************
   cat.get_superclusters(); // Here we selec tracers with bias above the fourth quartile
   // To do the interpolation, we use them all again if we want to explore density profiles, 
   //******************************************************
   // Now interplate bias on the mesh


   ULONG size_cat=cat.tracer_aux.size();


/*
   vector<real_prec>baux(size_cat,0);
   vector<real_prec>xaux(size_cat,0);
   vector<real_prec>yaux(size_cat,0);
   vector<real_prec>zaux(size_cat,0);


#ifdef _USE_OMP_
#pragma omp parallel for 
#endif  
   for(ULONG i=0;i<xaux.size(); ++i)
    {
        baux[i]=cat.tracer_aux[i].bias; // This bias is alkready above the
        xaux[i]=cat.tracer_aux[i].coord1;
        yaux[i]=cat.tracer_aux[i].coord2;
        zaux[i]=cat.tracer_aux[i].coord3;
    }
   vector<real_prec>Nfaux(this->params._NGRID(),0);
   getDensity_NGP(this->params._Nft(),this->params._Nft(),this->params._Nft(),this->params._Lbox(),this->params._Lbox(),this->params._Lbox(),this->params._d_delta_x(),this->params._d_delta_x(),this->params._d_delta_x(),0,0,0,xaux,yaux,zaux,zaux,Nfaux,false);
//   vector<real_prec>bfaux(this->params._NGRID(),0);
//   getDensity_NGP(this->params._Nft(),this->params._Nft(),this->params._Nft(),this->params._Lbox(),this->params._Lbox(),this->params._Lbox(),this->params._d_delta_x(),this->params._d_delta_x(),this->params._d_delta_x(),0,0,0,xaux,yaux,zaux,baux,bfaux,true);
  
   for(ULONG i=0;i<this->params._NGRID();++i)
    if(Nfaux[i]>0)
        bfaux[i]/=static_cast<real_prec>(Nfaux[i]);
    else
        bfaux[i]=0;


   xaux.clear();xaux.shrink_to_fit();
   yaux.clear();yaux.shrink_to_fit();
   zaux.clear();zaux.shrink_to_fit();

*/

  
/*
   real_prec mean_bias=0;
   real_prec ncount=0;
   for(ULONG i=0;i<this->params._NGRID();++i)
    if(Nfaux[i]>0)
      {
        ncount++;
        mean_bias+=bfaux[i];
      }
   mean_bias/=static_cast<real_prec>(ncount);
   So.message_screen("Mean bias from interpolation (from b>meab sample)=",mean_bias);
  */
   //******************************************************

   // Assign those cells a label to be used in the fof, e.g., I_KNOT

/*
   this->cwclass.set_params(this->params);
   this->cwclass.CWClass.clear();
   this->cwclass.CWClass.resize(this->params._NGRID(),0);
#ifdef _USE_OMP_
#pragma omp parallel for 
#endif  
   for(ULONG i=0;i<this->params._NGRID();++i)
        if(Nfaux[i]>0) //we treat the filled cells with objects above the fourth qaurttile as knots
            this->cwclass.CWClass[i] =I_KNOT;
   vector<real_prec>sk_index(this->params._NGRID(),0);// this contains for each cell the ID of the supercluster
   ULONG Nsk=0;
   this->cwclass.get_collapsing_regions(Nsk, sk_index);
   So.message_screen("Number of superclusters =", Nsk);
   //******************************************************
   //******************************************************
  */
   //******************************************************


/*
#ifdef _USE_OMP_
#pragma omp parallel for 
#endif  
   for(ULONG i=0;i<cat.tracer_aux.size();++i)
     cat.tracer_aux[i].galID=sk_index[cat.tracer_aux[i].GridID];// SuperCluster ID [0, Nsk) in which the current tracer lives
   
  */ 
   // get center of mass for each Super ID, xzcm=sum m_ix_i / sum m_i
   // WE use istead the bias from each tracer belonginh to the super knot to cpomute that center of mass
   // Then we compute the marked statistics using either mass or bias as marks.
   // When using mass as mark, we only see the bump at  low separations
   // but when using the bias as a mark, we see the bumb at small separations and somthing simular to tjhe acoustic poeak and a third peak.
   
   // Also, when using the mass to define the center of mass and marking with the bias, 
   // We see the the bumps
   // One way to isolate things is then to divide marked_bias / marked_mass


/*   
   So.message_screen("Getting center of mass for each SK");
   vector<real_prec>XCM(Nsk,0);//X-Coordinate of center of mass of SK
   vector<real_prec>YCM(Nsk,0);
   vector<real_prec>ZCM(Nsk,0);
   vector<real_prec>TB(Nsk,0);
   vector<real_prec>TP(Nsk,0);
   vector<real_prec>TS(Nsk,0);
   vector<real_prec>TMACH(Nsk,0);

   for(ULONG i=0;i<cat.tracer_aux.size();++i)
     {
       if(cat.tracer_aux[i].observed>0)
	 {
	   ULONG IDSK=cat.tracer_aux[i].galID;
	   real_prec bias=cat.tracer_aux[i].bias;  //We compute the center of mass of the SK using the bias instead of the mass
	   real_prec mass=cat.tracer_aux[i].mass;  //We compute the center of mass of the SK using the bias instead of the mass
	   TB[IDSK]+=bias; // get total bias in sk
	   TP[IDSK]+=mass;// Get total mass in SK
	   TS[IDSK]+=cat.tracer_aux[i].spin;  //Get total spin in SK
	   TMACH[IDSK]+=cat.tracer_aux[i].mach_number;  //Get total Machnumber in SK
	       infoc[IDSK].xp.push_back(cat.tracer_aux[i].coord1);
		     infoc[IDSK].yp.push_back(cat.tracer_aux[i].coord2);
		     infoc[IDSK].zp.push_back(cat.tracer_aux[i].coord3);
		     infoc[IDSK].mass.push_back(mass);
	   XCM[IDSK]+= cat.tracer_aux[i].coord1*mass;
	   YCM[IDSK]+= cat.tracer_aux[i].coord2*mass;
	   ZCM[IDSK]+= cat.tracer_aux[i].coord3*mass;
	 }
     }
   // Get coordinates of center of "bias" and mean marks among superknots
*/

   real_prec mean_mark_m=0;
   real_prec mean_mark_b=0;
   real_prec mean_mark_s=0;
   real_prec mean_mark_mach=0;
#ifdef _USE_OMP_
#pragma omp parallel for reduction(+:mean_mark_b,mean_mark_m,mean_mark_s,mean_mark_mach)
#endif  
   for(ULONG i=0;i<size_cat;++i)
     {
/*       mean_mark_m+=TP[i];
       mean_mark_s+=TS[i];
       mean_mark_b+=TB[i];
       mean_mark_mach+=TMACH[i];
       XCM[i]/=TP[i];
       YCM[i]/=TP[i];
       ZCM[i]/=TP[i];*/
       mean_mark_m+=cat.tracer_aux[i].mass;
       mean_mark_s+=cat.tracer_aux[i].spin;
       mean_mark_b+=cat.tracer_aux[i].bias;
       mean_mark_mach+=cat.tracer_aux[i].mach_number;
/*       XCM[i]/=TP[i];
       YCM[i]/=TP[i];
       ZCM[i]/=TP[i];*/



     }
   So.DONE();
   
   mean_mark_m/=static_cast<real_prec>(size_cat);
   mean_mark_b/=static_cast<real_prec>(size_cat);
   mean_mark_s/=static_cast<real_prec>(size_cat);
   mean_mark_mach/=static_cast<real_prec>(size_cat);

/*
   So.message_screen("Normalizing to mean marks");
#ifdef _USE_OMP_
#pragma omp parallel for 
#endif
   for(ULONG i=0;i<XCM.size();++i)
     {
       TP[i]/=mean_mark_m;
       TS[i]/=mean_mark_s;
       TB[i]/=mean_mark_b;
       TMACH[i]/=mean_mark_mach;
     }
   So.DONE();
  */
   So.message_screen("Computing 2pt stats");
   
   int Nrbins=this->params._Nbins_cf();
   real_prec rmax=this->params._rmax_cf();
   real_prec rmin=this->params._rmin_cf();
   real_prec lrmin=log10(rmin);
   real_prec deltar=log10(rmax/rmin)/static_cast<real_prec>(Nrbins);
   
   vector<real_prec>bcount(Nrbins,0);
   vector<real_prec>mcount(Nrbins,0);
   vector<real_prec>scount(Nrbins,0);
   vector<real_prec>machcount(Nrbins,0);
   vector<real_prec>gcount(Nrbins,0);

   ULONG Npairs=0;
#pragma omp parallel 
   {
     vector<real_prec> bcount_priv(Nrbins,0);
     vector<real_prec> mcount_priv(Nrbins,0);
     vector<real_prec> machcount_priv(Nrbins,0);
     vector<real_prec> gcount_priv(Nrbins,0);
     vector<real_prec> scount_priv(Nrbins,0);
#pragma omp for reduction(+:Npairs) collapse(2)
     for(ULONG i=0;i<size_cat;++i)
       for(ULONG j=i+1;j<size_cat;++j)
	 {
	   real_prec xp=cat.tracer_aux[i].coord1;
	   real_prec yp=cat.tracer_aux[i].coord2;
	   real_prec zp=cat.tracer_aux[i].coord3;
	   real_prec xq=cat.tracer_aux[j].coord1;
	   real_prec yq=cat.tracer_aux[j].coord2;
	   real_prec zq=cat.tracer_aux[j].coord3;
	   real_prec dx=xp-xq;
	   real_prec dy=yp-yq;
	   real_prec dz=zp-zq;
	   real_prec dist=dx*dx+dy*dy+dz*dz;
	   real_prec ldist=0.5*log10(dist);
	   ULONG ibin=get_bin(ldist,lrmin,Nrbins,deltar,false);
	   if(ibin<Nrbins) 
	     {
	       gcount_priv[ibin]++;  // marking with property=mass
	       bcount_priv[ibin]+=cat.tracer_aux[i].bias*cat.tracer_aux[j].bias/pow(mean_mark_b,2); // marking with bias
	       mcount_priv[ibin]+=cat.tracer_aux[i].mass*cat.tracer_aux[j].mass/pow(mean_mark_m,2);
	       scount_priv[ibin]+=cat.tracer_aux[i].spin*cat.tracer_aux[j].spin/pow(mean_mark_s,2);
	       machcount_priv[ibin]+=cat.tracer_aux[i].mach_number*cat.tracer_aux[j].mach_number/pow(mean_mark_mach,2); ;// marking with bias
	     }
           // Apply periodic boundary conditions:
	   dx=xp-xq+this->params._Lbox();
	   dy=yp-yq+this->params._Lbox();
	   dz=zp-zq+this->params._Lbox();
	   dist=dx*dx+dy*dy+dz*dz;
	   ldist=0.5*log10(dist);
	   ibin=get_bin(ldist,lrmin,Nrbins,deltar,false);
	   if(ibin<Nrbins) 
	     {
	       bcount_priv[ibin]+=cat.tracer_aux[i].bias*cat.tracer_aux[j].bias/pow(mean_mark_b,2) ; // marking with bias
	       mcount_priv[ibin]+=cat.tracer_aux[i].mass*cat.tracer_aux[j].mass/pow(mean_mark_m,2);  // marking with property=mass
	       scount_priv[ibin]+=cat.tracer_aux[i].spin*cat.tracer_aux[j].spin/pow(mean_mark_s,2); // marking with bias
	       machcount_priv[ibin]+=cat.tracer_aux[i].mach_number*cat.tracer_aux[j].mach_number/pow(mean_mark_mach,2);// marking with bias
	       gcount_priv[ibin]++;  // marking with property=mass
	     }
	   Npairs++;
	 }
#pragma omp critical
     {
       for(ULONG i=0;i<Nrbins;++i)
	 {
	   gcount[i]+= gcount_priv[i]/Npairs;
	   bcount[i]+= bcount_priv[i]/Npairs;
	   mcount[i]+= mcount_priv[i]/Npairs;
	   machcount[i]+= machcount_priv[i]/Npairs;
	   scount[i]+= scount_priv[i]/Npairs;
	 }
       scount_priv.clear();scount_priv.shrink_to_fit();
       gcount_priv.clear();gcount_priv.shrink_to_fit();
       mcount_priv.clear();mcount_priv.shrink_to_fit();
       machcount_priv.clear();machcount_priv.shrink_to_fit();
       bcount_priv.clear();bcount_priv.shrink_to_fit();
     }
   }
   So.DONE();

   // We now write rbin,      
   ofstream profd;
   string file;

   file=this->params._Output_directory()+"separation_distribtion_superk_mass.txt";
   profd.open(file);
   for(ULONG j=0;j<Nrbins;j++)
     profd<<rmin*pow(10,(j+0.5)*deltar)<<"\t"<<gcount[j]<<"\t"<<mcount[j]<<"\t"<<mcount[j]/gcount[j]<<endl;
   profd.close();

   file=this->params._Output_directory()+"separation_distribtion_superk_bias.txt";
   profd.open(file);
   for(ULONG j=0;j<Nrbins;j++)
     profd<<rmin*pow(10,(j+0.5)*deltar)<<"\t"<<gcount[j]<<"\t"<<bcount[j]<<"\t"<<bcount[j]/gcount[j]<<endl;
   profd.close();
   file=this->params._Output_directory()+"separation_distribtion_superk_spin.txt";
   profd.open(file);
   for(ULONG j=0;j<Nrbins;j++)
     profd<<rmin*pow(10,(j+0.5)*deltar)<<"\t"<<gcount[j]<<"\t"<<scount[j]<<"\t"<<scount[j]/gcount[j]<<endl;
   profd.close();
   file=this->params._Output_directory()+"separation_distribtion_superk_mach.txt";
   profd.open(file);
   for(ULONG j=0;j<Nrbins;j++)
     profd<<rmin*pow(10,(j+0.5)*deltar)<<"\t"<<gcount[j]<<"\t"<<machcount[j]<<"\t"<<machcount[j]/gcount[j]<<endl;
   profd.close();

   
   /*
   So.message_screen("Computing density profiles");
     ofstream skf(this->params._Output_directory()+"SK_coords.txt");
     for(ULONG i=0;i<XCM.size();++i)
     skf<<XCM[i]<<" "<<YCM[i]<<"  "<<ZCM[i]<<endl;
     skf.close();
     
     
     // Now the density profile for each supercluster:
     Nrbins=20;
     deltar=0.4;
     for(ULONG i=0;i<XCM.size();++i)
     {
     ofstream prof;
     string file=this->params._Output_directory()+"profile"+to_string(i)+".txt";
     prof.open(file);
     infoc[i].profile.resize(Nrbins,0);
     real_prec total_mass_superknot=0;
     for(ULONG j=0;j<infoc[i].xp.size();j++)
     total_mass_superknot+=infoc[i].mass[j];
     
     for(ULONG j=0;j<infoc[i].xp.size();j++)
     {
     real_prec xnew=infoc[i].xp[j]-XCM[i];
     real_prec ynew=infoc[i].yp[j]-YCM[i];
     real_prec znew=infoc[i].zp[j]-ZCM[i];
     real_prec r=sqrt(xnew*xnew+ynew*ynew+znew*znew);
     int rbin=get_bin(r,0,Nrbins,deltar,false);
     if(rbin<Nrbins)         
     infoc[i].profile[rbin]+=infoc[i].mass[j]/total_mass_superknot;
     }
     for(ULONG j=0;j<Nrbins;j++)
     prof<<(j+0.5)*deltar<<"  "<<infoc[i].profile[j]<<endl;
     prof.close();
     }   
   */
   So.DONE();
}
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************
 // ****************************************************************************************************************************************************************************************************************

